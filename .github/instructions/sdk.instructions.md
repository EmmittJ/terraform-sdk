---
applyTo: "**/src/EmmittJ.Terraform.Sdk/**"
---

# Core SDK Development Instructions

## üé® Terraform SDK Patterns

### Values System (`TerraformValue<T>`)

Polymorphic value storage providing type safety and implicit conversions:

```csharp
// Literals - automatic wrapping
TerraformValue<string> region = "us-west-2";
TerraformValue<int> count = 3;

// References - automatic dependency tracking
TerraformValue<string> vpcId = vpc["id"];

// Lazy evaluation - deferred computation
var value = TerraformValue<string>.Lazy(ctx =>
    condition ? TerraformExpression.Literal("a") : TerraformExpression.Literal("b")
);
```

**Key Points:**

- `TerraformValue<T>` where `T` is the **Terraform type** (string, double, bool)
- Values resolve to `TerraformExpression` nodes during resolution
- Collections: `TerraformList<T>`, `TerraformMap<T>`, `TerraformSet<T>`
- See `docs/values-system.md` for complete details

### Expressions System (`TerraformExpression`)

Compositional syntax builders for HCL constructs:

```csharp
// Literals and identifiers
TerraformExpression.Literal("us-west-2")
TerraformExpression.Identifier("var.region")

// Collections
TerraformExpression.List("a", "b", "c")
TerraformExpression.Object()  // Map/object

// Composition
TerraformExpression.Conditional(isProd, "prod-value", "dev-value")
TerraformExpression.Interpolate("prefix-", variable, "-suffix")
TerraformExpression.ForList(collection, item => item["id"])

// Operators (overloaded)
var sum = expr1 + expr2;
var name = vpc["id"];
```

**Key Points:**

- Expressions are **type-agnostic** - type safety happens at `TerraformValue<T>` level
- Immutable and compositional
- Expressions ARE syntax nodes (extend `TerraformSyntaxNode`)
- See `docs/expressions-system.md` for complete details

### Syntax System (`TerraformSyntaxNode`)

Direct HCL rendering layer:

```csharp
// Argument nodes (key = value)
new TerraformArgumentNode("region", TerraformExpression.Literal("us-west-2"))
// ‚Üí region = "us-west-2"

// Block nodes (nested blocks)
new TerraformBlockNode("tags", children)
// ‚Üí tags { ... }

// Top-level blocks (resources, providers, etc.)
new TerraformTopLevelBlockNode("resource", ["aws_vpc", "main"], children)
// ‚Üí resource "aws_vpc" "main" { ... }
```

**Key Points:**

- Syntax nodes know how to render themselves to HCL
- Context provides indentation management
- Automatic node ordering (meta-arguments first, alphabetical properties)
- See `docs/syntax-system.md` for complete details

## üîç Common Development Tasks

### Adding a New Block Type

1. Create class inheriting from `TerraformBlock`
2. Override `BlockType` property with the Terraform block type name
3. Override `Resolve()` to return appropriate `TerraformExpression`
4. Implement `AsReference()` if the block can be referenced (or if it can't throw `InvalidOperationException`)
5. Add XML documentation with Terraform spec link
6. Add comprehensive tests

### Terraform Documentation Links

Always include official Terraform documentation links in XML docs using `<para>Spec: <see href="..."/></para>`:

```csharp
/// <remarks>
/// <para>Spec: <see href="https://developer.hashicorp.com/terraform/language/resources"/></para>
/// </remarks>
```

**Key Documentation Areas**:

- Blocks: `/language/resources`, `/language/data-sources`, `/language/values/variables`, `/language/values/outputs`, `/language/values/locals`, `/language/modules/syntax`, `/language/providers/configuration`, `/language/import`, `/language/modules/develop/refactoring`, `/language/resources/ephemeral`, `/language/settings`, `/language/checks`
- Meta-arguments: `/language/meta-arguments` (count, for_each, depends_on, provider, lifecycle)
- Expressions: `/language/expressions/types`, `/language/expressions/references`, `/language/expressions/operators`
- Functions: `/language/functions`

## üåê Terraform-Specific Best Practices

### HCL Generation

- ‚úÖ Use proper indentation (2 spaces per level)
- ‚úÖ Quote string values, don't quote identifiers
- ‚úÖ Generate valid Terraform references (`${resource.name.attribute}`)
- ‚úÖ Escape special characters in strings
- ‚ùå Don't generate unnecessary whitespace

### Meta-Arguments

Meta-arguments (`count`, `for_each`, `depends_on`, `provider`, `lifecycle`) have special handling:

```csharp
// ‚úÖ Use interfaces for meta-argument support
public class TerraformResource : TerraformBlock,
    ITerraformHasCount,
    ITerraformHasForEach,
    ITerraformHasDependsOn,
    ITerraformHasProvider,
    ITerraformHasLifecycle
{
    // Meta-arguments are generated by source generators
}
```

### Provider Schema Compatibility

- ‚úÖ Generated providers should match Terraform Registry schemas exactly
- ‚úÖ Support all provider versions specified in generation config
- ‚úÖ Handle optional vs required attributes correctly
- ‚ùå Don't make assumptions about provider behavior
