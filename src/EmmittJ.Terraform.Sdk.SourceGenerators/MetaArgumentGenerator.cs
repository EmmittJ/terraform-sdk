using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace EmmittJ.Terraform.Sdk.SourceGenerators;

/// <summary>
/// Source generator that creates meta-argument property implementations for Terraform blocks.
/// Detects marker interfaces (ITerraformHasCount, ITerraformHasForEach, etc.) and generates
/// the corresponding properties using the base TerraformBlock's SetPropertyValue/GetPropertyValue infrastructure.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class MetaArgumentGenerator : IIncrementalGenerator
{
    private const string CountInterfaceName = "ITerraformHasCount";
    private const string ForEachInterfaceName = "ITerraformHasForEach";
    private const string DependsOnInterfaceName = "ITerraformHasDependsOn";
    private const string ProviderInterfaceName = "ITerraformHasProvider";
    private const string LifecycleInterfaceName = "ITerraformHasLifecycle";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all partial classes that implement meta-argument marker interfaces
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsPartialClassCandidate(node),
                transform: static (ctx, _) => GetClassInfo(ctx))
            .Where(static item => item is not null);

        // Generate property implementations for each class
        context.RegisterSourceOutput(classDeclarations, static (spc, source) => Execute(spc, source!));
    }

    private static bool IsPartialClassCandidate(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl
            && classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    private static ClassInfo? GetClassInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);

        if (classSymbol is null)
            return null;

        // Get all implemented interfaces
        var interfaces = classSymbol.AllInterfaces;

        // Check which meta-argument interfaces are implemented
        var hasCount = interfaces.Any(i => i.Name == CountInterfaceName);
        var hasForEach = interfaces.Any(i => i.Name == ForEachInterfaceName);
        var hasDependsOn = interfaces.Any(i => i.Name == DependsOnInterfaceName);
        var hasProvider = interfaces.Any(i => i.Name == ProviderInterfaceName);
        var hasLifecycle = interfaces.Any(i => i.Name == LifecycleInterfaceName);

        // Only generate if at least one marker interface is implemented
        if (!hasCount && !hasForEach && !hasDependsOn && !hasProvider && !hasLifecycle)
            return null;

        return new ClassInfo(
            Namespace: classSymbol.ContainingNamespace.ToDisplayString(),
            ClassName: classSymbol.Name,
            HasCount: hasCount,
            HasForEach: hasForEach,
            HasDependsOn: hasDependsOn,
            HasProvider: hasProvider,
            HasLifecycle: hasLifecycle);
    }

    private static void Execute(SourceProductionContext context, ClassInfo classInfo)
    {
        var source = GenerateMetaArgumentProperties(classInfo);
        context.AddSource($"{classInfo.ClassName}.MetaArguments.g.cs", source);
    }

    private static string GenerateMetaArgumentProperties(ClassInfo classInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {classInfo.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    partial class {classInfo.ClassName}");
        sb.AppendLine("    {");

        // Generate Count property
        if (classInfo.HasCount)
        {
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets or sets the count meta-argument.");
            sb.AppendLine("        /// Accepts a whole number, and creates that many instances of the block.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public EmmittJ.Terraform.Sdk.TerraformValue<int>? Count");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetPropertyValue<EmmittJ.Terraform.Sdk.TerraformValue<int>?>(\"count\");");
            sb.AppendLine("            set => SetPropertyValue(\"count\", value);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // Generate ForEach property
        if (classInfo.HasForEach)
        {
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets or sets the for_each meta-argument.");
            sb.AppendLine("        /// Accepts a map or a set of strings, and creates an instance for each item.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public EmmittJ.Terraform.Sdk.TerraformValue<object>? ForEach");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetPropertyValue<EmmittJ.Terraform.Sdk.TerraformValue<object>?>(\"for_each\");");
            sb.AppendLine("            set => SetPropertyValue(\"for_each\", value);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // Generate DependsOn property
        if (classInfo.HasDependsOn)
        {
            sb.AppendLine("        private System.Collections.Generic.List<string>? _dependsOn;");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets the list of resources this depends on.");
            sb.AppendLine("        /// Use this meta-argument when a block relies on some other block's behavior");
            sb.AppendLine("        /// but doesn't access any of that block's data in its arguments.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public System.Collections.Generic.List<string> DependsOn");
            sb.AppendLine("        {");
            sb.AppendLine("            get => _dependsOn ??= new System.Collections.Generic.List<string>();");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // Generate Provider property
        if (classInfo.HasProvider)
        {
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets or sets the provider meta-argument.");
            sb.AppendLine("        /// Specifies which provider configuration to use, overriding Terraform's default behavior.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public string? Provider");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetPropertyValue<string?>(\"provider\");");
            sb.AppendLine("            set => SetPropertyValue(\"provider\", value);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        // Generate Lifecycle property
        if (classInfo.HasLifecycle)
        {
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets or sets the lifecycle configuration for this resource.");
            sb.AppendLine("        /// Allows customization of lifecycle behavior including create_before_destroy, prevent_destroy, and ignore_changes.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public EmmittJ.Terraform.Sdk.TerraformLifecycleConfig? Lifecycle");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetPropertyValue<EmmittJ.Terraform.Sdk.TerraformLifecycleConfig?>(\"lifecycle\");");
            sb.AppendLine("            set => SetPropertyValue(\"lifecycle\", value);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private record ClassInfo(
        string Namespace,
        string ClassName,
        bool HasCount,
        bool HasForEach,
        bool HasDependsOn,
        bool HasProvider,
        bool HasLifecycle);
}
