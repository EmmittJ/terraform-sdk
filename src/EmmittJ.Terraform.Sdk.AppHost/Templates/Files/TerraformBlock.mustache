using EmmittJ.Terraform.Sdk;

namespace {{Namespace}};

// Resources, Data Sources, Ephemeral Resources, Blocks: Getter ALWAYS returns a reference
// This is the key to natural Terraform syntax
// When you access rg.Name, you get azurerm_resource_group.rg.name (a reference)
// The value that was SET is only used during serialization

// Providers: Getter returns stored value
// Providers are not referenced in HCL
// Use required getter if property is required or non-nullable

{{#BlockTypes}}
/// <summary>
/// Block type for {{TerraformName}} in {{../ClassName}}.
/// Nesting mode: {{NestingMode}}
/// </summary>
{{#IsDeprecated}}
[Obsolete("This block is deprecated.")]
{{/IsDeprecated}}
public class {{ClassName}} : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "{{TerraformName}}";

{{#Properties}}
{{^IsComputedAttribute}}
    /// <summary>
    /// {{Description}}
    /// </summary>
{{#IsRequired}}
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "{{Name}} is required")]
{{/IsRequired}}
{{#IsDeprecated}}
    [Obsolete("This property is deprecated.")]
{{/IsDeprecated}}
    [TerraformArgument("{{TerraformName}}")]
{{#IsRequiredArgument}}
{{#UseRequiredKeyword}}
    public required {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseRequiredKeyword}}
{{#UseNullable}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}}? {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseNullable}}
{{/IsRequiredArgument}}
{{#IsOptionalArgument}}
{{#UseRequiredKeyword}}
    public required {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseRequiredKeyword}}
{{#UseNullable}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}}? {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseNullable}}
{{/IsOptionalArgument}}
{{#IsOptionalAndComputed}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/IsOptionalAndComputed}}
{{/IsComputedAttribute}}

{{/Properties}}
}

{{/BlockTypes}}
/// <summary>
/// {{Description}}{{#AdditionalDescription}}
/// {{AdditionalDescription}}{{/AdditionalDescription}}
/// </summary>
{{#IsDeprecated}}
[Obsolete("This {{BlockKind}} is deprecated.")]
{{/IsDeprecated}}
{{#RequiresUnreferencedCode}}
[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("This class uses MinLength/MaxLength validation attributes which use reflection.")]
{{/RequiresUnreferencedCode}}
public class {{ClassName}} : {{BaseClassName}}
{
    public {{ClassName}}(string name) : base("{{TerraformType}}", name)
    {
    }

{{#Properties}}
    /// <summary>
    /// {{Description}}
    /// </summary>
{{#IsRequired}}
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "{{Name}} is required")]
{{/IsRequired}}
{{#IsDeprecated}}
    [Obsolete("This property is deprecated.")]
{{/IsDeprecated}}
    [TerraformArgument("{{TerraformName}}")]
{{#IsRequiredArgument}}
{{#UseRequiredKeyword}}
    public required {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseRequiredKeyword}}
{{#UseNullable}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}}? {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseNullable}}
{{/IsRequiredArgument}}
{{#IsOptionalArgument}}
{{#UseRequiredKeyword}}
    public required {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseRequiredKeyword}}
{{#UseNullable}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}}? {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/UseNullable}}
{{/IsOptionalArgument}}
{{#IsOptionalAndComputed}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
        set => SetArgument("{{TerraformName}}", value);
    }
{{/IsOptionalAndComputed}}
{{#IsComputedAttribute}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
    }
{{/IsComputedAttribute}}

{{/Properties}}
{{#BlockTypes}}
    /// <summary>
    /// Block for {{TerraformName}}.
    /// Nesting mode: {{NestingMode}}
    /// </summary>
{{#ValidationAttributes}}
    {{{.}}}
{{/ValidationAttributes}}
{{#IsDeprecated}}
    [Obsolete("This block is deprecated.")]
{{/IsDeprecated}}
    [TerraformArgument("{{TerraformName}}")]
{{#UseRequiredKeyword}}
{{#UseBlockLabelInInitializer}}
    public required {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{BlockPropertyType}}} {{Name}} { get; set; } = new();
{{/UseBlockLabelInInitializer}}
{{^UseBlockLabelInInitializer}}
    public required {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{BlockPropertyType}}} {{Name}} { get; set; } = new();
{{/UseBlockLabelInInitializer}}
{{/UseRequiredKeyword}}
{{^UseRequiredKeyword}}
{{#UseBlockLabelInInitializer}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{BlockPropertyType}}} {{Name}} { get; set; } = new();
{{/UseBlockLabelInInitializer}}
{{^UseBlockLabelInInitializer}}
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{BlockPropertyType}}} {{Name}} { get; set; } = new();
{{/UseBlockLabelInInitializer}}
{{/UseRequiredKeyword}}

{{/BlockTypes}}
{{#OutputAttributes}}
    /// <summary>
    /// {{Description}}
    /// </summary>
    [TerraformArgument("{{TerraformName}}")]
    public {{#NeedsNewKeyword}}new {{/NeedsNewKeyword}}{{{PropertyWrapper}}} {{Name}}
    {
{{#IsCollectionType}}
        get => {{{CollectionTypeName}}}<{{{CollectionElementType}}}>.Lazy(ctx => new TerraformReference<{{{PropertyWrapper}}}>(this, "{{TerraformName}}").ResolveNodes(ctx));
{{/IsCollectionType}}
{{^IsCollectionType}}
        get => new TerraformReference<{{{InnerType}}}>(this, "{{TerraformName}}");
{{/IsCollectionType}}
    }

{{/OutputAttributes}}
}
