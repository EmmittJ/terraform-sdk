using EmmittJ.Terraform.Sdk;

namespace EmmittJ.Terraform.Sdk.Providers.Google;

/// <summary>
/// Represents a google_cloud_run_service Terraform data source.
/// Retrieves information about a google_cloud_run_service.
/// </summary>
public partial class GoogleCloudRunServiceDataSource(string name) : TerraformDataSource("google_cloud_run_service", name)
{
    /// <summary>
    /// The id attribute.
    /// </summary>
    public TerraformValue<string> Id
    {
        get => new TerraformReference<string>(this, "id");
        set => SetArgument("id", value);
    }

    /// <summary>
    /// The location of the cloud run instance. eg us-central1
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Location is required")]
    public required TerraformValue<string> Location
    {
        get => new TerraformReference<string>(this, "location");
        set => SetArgument("location", value);
    }

    /// <summary>
    /// Name must be unique within a Google Cloud project and region.
    /// Is required when creating resources. Name is primarily intended
    /// for creation idempotence and configuration definition. Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Name is required")]
    public required TerraformValue<string> Name
    {
        get => new TerraformReference<string>(this, "name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// The project attribute.
    /// </summary>
    public TerraformValue<string>? Project
    {
        get => new TerraformReference<string>(this, "project");
        set => SetArgument("project", value);
    }

    /// <summary>
    /// If set to &#39;true&#39;, the revision name (template.metadata.name) will be omitted and
    /// autogenerated by Cloud Run. This cannot be set to &#39;true&#39; while &#39;template.metadata.name&#39;
    /// is also set.
    /// (For legacy support, if &#39;template.metadata.name&#39; is unset in state while
    /// this field is set to false, the revision name will still autogenerate.)
    /// </summary>
    public TerraformValue<bool> AutogenerateRevisionName
    {
        get => new TerraformReference<bool>(this, "autogenerate_revision_name");
    }

    /// <summary>
    /// Metadata associated with this Service, including name, namespace, labels,
    /// and annotations.
    /// </summary>
    public TerraformList<TerraformMap<object>> Metadata
    {
        get => TerraformList<TerraformMap<object>>.Lazy(ctx => new TerraformReference<TerraformList<TerraformMap<object>>>(this, "metadata").ResolveNodes(ctx));
    }

    /// <summary>
    /// The current status of the Service.
    /// </summary>
    public TerraformList<TerraformMap<object>> Status
    {
        get => TerraformList<TerraformMap<object>>.Lazy(ctx => new TerraformReference<TerraformList<TerraformMap<object>>>(this, "status").ResolveNodes(ctx));
    }

    /// <summary>
    /// template holds the latest specification for the Revision to
    /// be stamped out. The template references the container image, and may also
    /// include labels and annotations that should be attached to the Revision.
    /// To correlate a Revision, and/or to force a Revision to be created when the
    /// spec doesn&#39;t otherwise change, a nonce label may be provided in the
    /// template metadata. For more details, see:
    /// https://github.com/knative/serving/blob/main/docs/client-conventions.md#associate-modifications-with-revisions
    /// 
    /// Cloud Run does not currently support referencing a build that is
    /// responsible for materializing the container image from source.
    /// </summary>
    public TerraformList<TerraformMap<object>> Template
    {
        get => TerraformList<TerraformMap<object>>.Lazy(ctx => new TerraformReference<TerraformList<TerraformMap<object>>>(this, "template").ResolveNodes(ctx));
    }

    /// <summary>
    /// Traffic specifies how to distribute traffic over a collection of Knative Revisions
    /// and Configurations
    /// </summary>
    public TerraformList<TerraformMap<object>> Traffic
    {
        get => TerraformList<TerraformMap<object>>.Lazy(ctx => new TerraformReference<TerraformList<TerraformMap<object>>>(this, "traffic").ResolveNodes(ctx));
    }

}
