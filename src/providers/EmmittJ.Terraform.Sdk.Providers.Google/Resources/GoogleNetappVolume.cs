using EmmittJ.Terraform.Sdk;

namespace EmmittJ.Terraform.Sdk.Providers.Google;

/// <summary>
/// Block type for backup_config in GoogleNetappVolume.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeBackupConfigBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "backup_config";

    /// <summary>
    /// Specify a single backup policy ID for scheduled backups. Format: &#39;projects/{{projectId}}/locations/{{location}}/backupPolicies/{{backupPolicyName}}&#39;
    /// </summary>
    public TerraformList<string>? BackupPolicies
    {
        get => TerraformList<string>.Lazy(ctx => new TerraformReference<TerraformList<string>>(this, "backup_policies").ResolveNodes(ctx));
        set => SetArgument("backup_policies", value);
    }

    /// <summary>
    /// ID of the backup vault to use. A backup vault is reqired to create manual or scheduled backups.
    /// Format: &#39;projects/{{projectId}}/locations/{{location}}/backupVaults/{{backupVaultName}}&#39;
    /// </summary>
    public TerraformValue<string>? BackupVault
    {
        get => new TerraformReference<string>(this, "backup_vault");
        set => SetArgument("backup_vault", value);
    }

    /// <summary>
    /// When set to true, scheduled backup is enabled on the volume. Omit if no backup_policy is specified.
    /// </summary>
    public TerraformValue<bool>? ScheduledBackupEnabled
    {
        get => new TerraformReference<bool>(this, "scheduled_backup_enabled");
        set => SetArgument("scheduled_backup_enabled", value);
    }

}


/// <summary>
/// Block type for block_devices in GoogleNetappVolume.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeBlockDevicesBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "block_devices";

    /// <summary>
    /// A list of host groups that identify hosts that can mount the block volume.
    /// Format:
    /// &#39;projects/{project_id}/locations/{location}/hostGroups/{host_group_id}&#39;
    /// This field can be updated after the block device is created.
    /// </summary>
    public TerraformList<string> HostGroups
    {
        get => TerraformList<string>.Lazy(ctx => new TerraformReference<TerraformList<string>>(this, "host_groups").ResolveNodes(ctx));
        set => SetArgument("host_groups", value);
    }

    /// <summary>
    /// Device identifier of the Block volume. This represents lun_serial_number
    /// for ISCSI volumes
    /// </summary>
    public TerraformValue<string> Identifier
    {
        get => new TerraformReference<string>(this, "identifier");
    }

    /// <summary>
    /// User-defined name for the block device, unique within the Volume. In case
    /// no user input is provided, name will be autogenerated in the backend.
    /// The name must meet the following requirements:
    /// *   Be between 1 and 255 characters long.
    /// *   Contain only uppercase or lowercase letters (A-Z, a-z), numbers (0-9),
    ///     and the following special characters: &amp;quot;-&amp;quot;, &amp;quot;_&amp;quot;, &amp;quot;}&amp;quot;, &amp;quot;{&amp;quot;, &amp;quot;.&amp;quot;.
    /// *   Spaces are not allowed.
    /// </summary>
    public TerraformValue<string> Name
    {
        get => new TerraformReference<string>(this, "name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// The OS type of the volume.
    /// This field can&#39;t be changed after the block device is created. Possible values: [&amp;quot;LINUX&amp;quot;, &amp;quot;WINDOWS&amp;quot;, &amp;quot;ESXI&amp;quot;]
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "OsType is required")]
    public required TerraformValue<string> OsType
    {
        get => new TerraformReference<string>(this, "os_type");
        set => SetArgument("os_type", value);
    }

    /// <summary>
    /// The size of the block device in GiB.
    /// Any value provided in this field during Volume creation is IGNORED.
    /// The block device&#39;s size is system-managed and will be set to match
    /// the parent Volume&#39;s &#39;capacity_gib&#39;.
    /// </summary>
    public TerraformValue<double> SizeGib
    {
        get => new TerraformReference<double>(this, "size_gib");
    }

}


/// <summary>
/// Block type for export_policy in GoogleNetappVolume.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeExportPolicyBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "export_policy";

    /// <summary>
    /// Rules block (nesting mode: list).
    /// This block is required.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Rules is required")]
    [System.ComponentModel.DataAnnotations.MinLength(1, ErrorMessage = "At least 1 Rules block(s) required")]
    public required TerraformList<GoogleNetappVolumeExportPolicyBlockRulesBlock> Rules
    {
        get => GetRequiredArgument<TerraformList<GoogleNetappVolumeExportPolicyBlockRulesBlock>>("rules");
        set => SetArgument("rules", value);
    }

}

/// <summary>
/// Block type for rules in GoogleNetappVolumeExportPolicyBlock.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeExportPolicyBlockRulesBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "rules";

    /// <summary>
    /// Defines the access type for clients matching the &#39;allowedClients&#39; specification. Possible values: [&amp;quot;READ_ONLY&amp;quot;, &amp;quot;READ_WRITE&amp;quot;, &amp;quot;READ_NONE&amp;quot;]
    /// </summary>
    public TerraformValue<string>? AccessType
    {
        get => new TerraformReference<string>(this, "access_type");
        set => SetArgument("access_type", value);
    }

    /// <summary>
    /// Defines the client ingress specification (allowed clients) as a comma separated list with IPv4 CIDRs or IPv4 host addresses.
    /// </summary>
    public TerraformValue<string>? AllowedClients
    {
        get => new TerraformReference<string>(this, "allowed_clients");
        set => SetArgument("allowed_clients", value);
    }

    /// <summary>
    /// An integer representing the anonymous user ID. Range is 0 to 4294967295. Required when &#39;squash_mode&#39; is &#39;ROOT_SQUASH&#39; or &#39;ALL_SQUASH&#39;.
    /// </summary>
    public TerraformValue<double>? AnonUid
    {
        get => new TerraformReference<double>(this, "anon_uid");
        set => SetArgument("anon_uid", value);
    }

    /// <summary>
    /// If enabled, the root user (UID = 0) of the specified clients doesn&#39;t get mapped to nobody (UID = 65534). This is also known as no_root_squash.
    /// </summary>
    public TerraformValue<string> HasRootAccess
    {
        get => new TerraformReference<string>(this, "has_root_access");
        set => SetArgument("has_root_access", value);
    }

    /// <summary>
    /// If enabled (true) the rule defines a read only access for clients matching the &#39;allowedClients&#39; specification. It enables nfs clients to mount using &#39;authentication&#39; kerberos security mode.
    /// </summary>
    public TerraformValue<bool>? Kerberos5ReadOnly
    {
        get => new TerraformReference<bool>(this, "kerberos5_read_only");
        set => SetArgument("kerberos5_read_only", value);
    }

    /// <summary>
    /// If enabled (true) the rule defines read and write access for clients matching the &#39;allowedClients&#39; specification. It enables nfs clients to mount using &#39;authentication&#39; kerberos security mode. The &#39;kerberos5ReadOnly&#39; value is ignored if this is enabled.
    /// </summary>
    public TerraformValue<bool>? Kerberos5ReadWrite
    {
        get => new TerraformReference<bool>(this, "kerberos5_read_write");
        set => SetArgument("kerberos5_read_write", value);
    }

    /// <summary>
    /// If enabled (true) the rule defines a read only access for clients matching the &#39;allowedClients&#39; specification. It enables nfs clients to mount using &#39;integrity&#39; kerberos security mode.
    /// </summary>
    public TerraformValue<bool>? Kerberos5iReadOnly
    {
        get => new TerraformReference<bool>(this, "kerberos5i_read_only");
        set => SetArgument("kerberos5i_read_only", value);
    }

    /// <summary>
    /// If enabled (true) the rule defines read and write access for clients matching the &#39;allowedClients&#39; specification. It enables nfs clients to mount using &#39;integrity&#39; kerberos security mode. The &#39;kerberos5iReadOnly&#39; value is ignored if this is enabled.
    /// </summary>
    public TerraformValue<bool>? Kerberos5iReadWrite
    {
        get => new TerraformReference<bool>(this, "kerberos5i_read_write");
        set => SetArgument("kerberos5i_read_write", value);
    }

    /// <summary>
    /// If enabled (true) the rule defines a read only access for clients matching the &#39;allowedClients&#39; specification. It enables nfs clients to mount using &#39;privacy&#39; kerberos security mode.
    /// </summary>
    public TerraformValue<bool>? Kerberos5pReadOnly
    {
        get => new TerraformReference<bool>(this, "kerberos5p_read_only");
        set => SetArgument("kerberos5p_read_only", value);
    }

    /// <summary>
    /// If enabled (true) the rule defines read and write access for clients matching the &#39;allowedClients&#39; specification. It enables nfs clients to mount using &#39;privacy&#39; kerberos security mode. The &#39;kerberos5pReadOnly&#39; value is ignored if this is enabled.
    /// </summary>
    public TerraformValue<bool>? Kerberos5pReadWrite
    {
        get => new TerraformReference<bool>(this, "kerberos5p_read_write");
        set => SetArgument("kerberos5p_read_write", value);
    }

    /// <summary>
    /// Enable to apply the export rule to NFSV3 clients.
    /// </summary>
    public TerraformValue<bool>? Nfsv3
    {
        get => new TerraformReference<bool>(this, "nfsv3");
        set => SetArgument("nfsv3", value);
    }

    /// <summary>
    /// Enable to apply the export rule to NFSV4.1 clients.
    /// </summary>
    public TerraformValue<bool>? Nfsv4
    {
        get => new TerraformReference<bool>(this, "nfsv4");
        set => SetArgument("nfsv4", value);
    }

    /// <summary>
    /// SquashMode defines how remote user privileges are restricted when accessing an NFS export. It controls how the user identities (like root) are mapped to anonymous users to limit access and enforce security. Possible values: [&amp;quot;NO_ROOT_SQUASH&amp;quot;, &amp;quot;ROOT_SQUASH&amp;quot;, &amp;quot;ALL_SQUASH&amp;quot;]
    /// </summary>
    public TerraformValue<string> SquashMode
    {
        get => new TerraformReference<string>(this, "squash_mode");
        set => SetArgument("squash_mode", value);
    }

}


/// <summary>
/// Block type for hybrid_replication_parameters in GoogleNetappVolume.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeHybridReplicationParametersBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "hybrid_replication_parameters";

    /// <summary>
    /// Optional. Name of source cluster location associated with the Hybrid replication. This is a free-form field for the display purpose only.
    /// </summary>
    public TerraformValue<string>? ClusterLocation
    {
        get => new TerraformReference<string>(this, "cluster_location");
        set => SetArgument("cluster_location", value);
    }

    /// <summary>
    /// Optional. Description of the replication.
    /// </summary>
    public TerraformValue<string>? Description
    {
        get => new TerraformReference<string>(this, "description");
        set => SetArgument("description", value);
    }

    /// <summary>
    /// Optional. Type of the volume&#39;s hybrid replication. Possible values: [&amp;quot;MIGRATION&amp;quot;, &amp;quot;CONTINUOUS_REPLICATION&amp;quot;, &amp;quot;ONPREM_REPLICATION&amp;quot;, &amp;quot;REVERSE_ONPREM_REPLICATION&amp;quot;]
    /// </summary>
    public TerraformValue<string>? HybridReplicationType
    {
        get => new TerraformReference<string>(this, "hybrid_replication_type");
        set => SetArgument("hybrid_replication_type", value);
    }

    /// <summary>
    /// Optional. Labels to be added to the replication as the key value pairs.
    /// An object containing a list of &amp;quot;key&amp;quot;: value pairs. Example: { &amp;quot;name&amp;quot;: &amp;quot;wrench&amp;quot;, &amp;quot;mass&amp;quot;: &amp;quot;1.3kg&amp;quot;, &amp;quot;count&amp;quot;: &amp;quot;3&amp;quot; }.
    /// </summary>
    public TerraformMap<string>? Labels
    {
        get => TerraformMap<string>.Lazy(ctx => new TerraformReference<TerraformMap<string>>(this, "labels").ResolveNodes(ctx));
        set => SetArgument("labels", value);
    }

    /// <summary>
    /// Optional. Constituent volume count for large volume.
    /// </summary>
    public TerraformValue<double>? LargeVolumeConstituentCount
    {
        get => new TerraformReference<double>(this, "large_volume_constituent_count");
        set => SetArgument("large_volume_constituent_count", value);
    }

    /// <summary>
    /// Required. Name of the user&#39;s local source cluster to be peered with the destination cluster.
    /// </summary>
    public TerraformValue<string>? PeerClusterName
    {
        get => new TerraformReference<string>(this, "peer_cluster_name");
        set => SetArgument("peer_cluster_name", value);
    }

    /// <summary>
    /// Required. List of node ip addresses to be peered with.
    /// </summary>
    public TerraformList<string>? PeerIpAddresses
    {
        get => TerraformList<string>.Lazy(ctx => new TerraformReference<TerraformList<string>>(this, "peer_ip_addresses").ResolveNodes(ctx));
        set => SetArgument("peer_ip_addresses", value);
    }

    /// <summary>
    /// Required. Name of the user&#39;s local source vserver svm to be peered with the destination vserver svm.
    /// </summary>
    public TerraformValue<string>? PeerSvmName
    {
        get => new TerraformReference<string>(this, "peer_svm_name");
        set => SetArgument("peer_svm_name", value);
    }

    /// <summary>
    /// Required. Name of the user&#39;s local source volume to be peered with the destination volume.
    /// </summary>
    public TerraformValue<string>? PeerVolumeName
    {
        get => new TerraformReference<string>(this, "peer_volume_name");
        set => SetArgument("peer_volume_name", value);
    }

    /// <summary>
    /// Required. Desired name for the replication of this volume.
    /// </summary>
    public TerraformValue<string>? Replication
    {
        get => new TerraformReference<string>(this, "replication");
        set => SetArgument("replication", value);
    }

    /// <summary>
    /// Optional. Replication Schedule for the replication created. Possible values: [&amp;quot;EVERY_10_MINUTES&amp;quot;, &amp;quot;HOURLY&amp;quot;, &amp;quot;DAILY&amp;quot;]
    /// </summary>
    public TerraformValue<string>? ReplicationSchedule
    {
        get => new TerraformReference<string>(this, "replication_schedule");
        set => SetArgument("replication_schedule", value);
    }

}


/// <summary>
/// Block type for restore_parameters in GoogleNetappVolume.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeRestoreParametersBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "restore_parameters";

    /// <summary>
    /// Full name of the backup to use for creating this volume.
    /// &#39;source_snapshot&#39; and &#39;source_backup&#39; cannot be used simultaneously.
    /// Format: &#39;projects/{{project}}/locations/{{location}}/backupVaults/{{backupVaultId}}/backups/{{backup}}&#39;.
    /// </summary>
    public TerraformValue<string>? SourceBackup
    {
        get => new TerraformReference<string>(this, "source_backup");
        set => SetArgument("source_backup", value);
    }

    /// <summary>
    /// Full name of the snapshot to use for creating this volume.
    /// &#39;source_snapshot&#39; and &#39;source_backup&#39; cannot be used simultaneously.
    /// Format: &#39;projects/{{project}}/locations/{{location}}/volumes/{{volume}}/snapshots/{{snapshot}}&#39;.
    /// </summary>
    public TerraformValue<string>? SourceSnapshot
    {
        get => new TerraformReference<string>(this, "source_snapshot");
        set => SetArgument("source_snapshot", value);
    }

}


/// <summary>
/// Block type for snapshot_policy in GoogleNetappVolume.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeSnapshotPolicyBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "snapshot_policy";

    /// <summary>
    /// Enables automated snapshot creation according to defined schedule. Default is false.
    /// To disable automatic snapshot creation you have to remove the whole snapshot_policy block.
    /// </summary>
    public TerraformValue<bool>? Enabled
    {
        get => new TerraformReference<bool>(this, "enabled");
        set => SetArgument("enabled", value);
    }

    /// <summary>
    /// DailySchedule block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 DailySchedule block(s) allowed")]
    public TerraformList<GoogleNetappVolumeSnapshotPolicyBlockDailyScheduleBlock>? DailySchedule
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeSnapshotPolicyBlockDailyScheduleBlock>>("daily_schedule");
        set => SetArgument("daily_schedule", value);
    }

    /// <summary>
    /// HourlySchedule block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 HourlySchedule block(s) allowed")]
    public TerraformList<GoogleNetappVolumeSnapshotPolicyBlockHourlyScheduleBlock>? HourlySchedule
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeSnapshotPolicyBlockHourlyScheduleBlock>>("hourly_schedule");
        set => SetArgument("hourly_schedule", value);
    }

    /// <summary>
    /// MonthlySchedule block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 MonthlySchedule block(s) allowed")]
    public TerraformList<GoogleNetappVolumeSnapshotPolicyBlockMonthlyScheduleBlock>? MonthlySchedule
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeSnapshotPolicyBlockMonthlyScheduleBlock>>("monthly_schedule");
        set => SetArgument("monthly_schedule", value);
    }

    /// <summary>
    /// WeeklySchedule block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 WeeklySchedule block(s) allowed")]
    public TerraformList<GoogleNetappVolumeSnapshotPolicyBlockWeeklyScheduleBlock>? WeeklySchedule
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeSnapshotPolicyBlockWeeklyScheduleBlock>>("weekly_schedule");
        set => SetArgument("weekly_schedule", value);
    }

}

/// <summary>
/// Block type for daily_schedule in GoogleNetappVolumeSnapshotPolicyBlock.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeSnapshotPolicyBlockDailyScheduleBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "daily_schedule";

    /// <summary>
    /// Set the hour to create the snapshot (0-23), defaults to midnight (0).
    /// </summary>
    public TerraformValue<double>? Hour
    {
        get => new TerraformReference<double>(this, "hour");
        set => SetArgument("hour", value);
    }

    /// <summary>
    /// Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
    /// </summary>
    public TerraformValue<double>? Minute
    {
        get => new TerraformReference<double>(this, "minute");
        set => SetArgument("minute", value);
    }

    /// <summary>
    /// The maximum number of snapshots to keep for the daily schedule.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "SnapshotsToKeep is required")]
    public required TerraformValue<double> SnapshotsToKeep
    {
        get => new TerraformReference<double>(this, "snapshots_to_keep");
        set => SetArgument("snapshots_to_keep", value);
    }

}

/// <summary>
/// Block type for hourly_schedule in GoogleNetappVolumeSnapshotPolicyBlock.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeSnapshotPolicyBlockHourlyScheduleBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "hourly_schedule";

    /// <summary>
    /// Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
    /// </summary>
    public TerraformValue<double>? Minute
    {
        get => new TerraformReference<double>(this, "minute");
        set => SetArgument("minute", value);
    }

    /// <summary>
    /// The maximum number of snapshots to keep for the hourly schedule.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "SnapshotsToKeep is required")]
    public required TerraformValue<double> SnapshotsToKeep
    {
        get => new TerraformReference<double>(this, "snapshots_to_keep");
        set => SetArgument("snapshots_to_keep", value);
    }

}

/// <summary>
/// Block type for monthly_schedule in GoogleNetappVolumeSnapshotPolicyBlock.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeSnapshotPolicyBlockMonthlyScheduleBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "monthly_schedule";

    /// <summary>
    /// Set the day or days of the month to make a snapshot (1-31). Accepts a comma separated number of days. Defaults to &#39;1&#39;.
    /// </summary>
    public TerraformValue<string>? DaysOfMonth
    {
        get => new TerraformReference<string>(this, "days_of_month");
        set => SetArgument("days_of_month", value);
    }

    /// <summary>
    /// Set the hour to create the snapshot (0-23), defaults to midnight (0).
    /// </summary>
    public TerraformValue<double>? Hour
    {
        get => new TerraformReference<double>(this, "hour");
        set => SetArgument("hour", value);
    }

    /// <summary>
    /// Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
    /// </summary>
    public TerraformValue<double>? Minute
    {
        get => new TerraformReference<double>(this, "minute");
        set => SetArgument("minute", value);
    }

    /// <summary>
    /// The maximum number of snapshots to keep for the monthly schedule
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "SnapshotsToKeep is required")]
    public required TerraformValue<double> SnapshotsToKeep
    {
        get => new TerraformReference<double>(this, "snapshots_to_keep");
        set => SetArgument("snapshots_to_keep", value);
    }

}

/// <summary>
/// Block type for weekly_schedule in GoogleNetappVolumeSnapshotPolicyBlock.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeSnapshotPolicyBlockWeeklyScheduleBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "weekly_schedule";

    /// <summary>
    /// Set the day or days of the week to make a snapshot. Accepts a comma separated days of the week. Defaults to &#39;Sunday&#39;.
    /// </summary>
    public TerraformValue<string>? Day
    {
        get => new TerraformReference<string>(this, "day");
        set => SetArgument("day", value);
    }

    /// <summary>
    /// Set the hour to create the snapshot (0-23), defaults to midnight (0).
    /// </summary>
    public TerraformValue<double>? Hour
    {
        get => new TerraformReference<double>(this, "hour");
        set => SetArgument("hour", value);
    }

    /// <summary>
    /// Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
    /// </summary>
    public TerraformValue<double>? Minute
    {
        get => new TerraformReference<double>(this, "minute");
        set => SetArgument("minute", value);
    }

    /// <summary>
    /// The maximum number of snapshots to keep for the weekly schedule.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "SnapshotsToKeep is required")]
    public required TerraformValue<double> SnapshotsToKeep
    {
        get => new TerraformReference<double>(this, "snapshots_to_keep");
        set => SetArgument("snapshots_to_keep", value);
    }

}


/// <summary>
/// Block type for tiering_policy in GoogleNetappVolume.
/// Nesting mode: list
/// </summary>
public class GoogleNetappVolumeTieringPolicyBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "tiering_policy";

    /// <summary>
    /// Optional. Time in days to mark the volume&#39;s data block as cold and make it eligible for tiering, can be range from 2-183.
    /// Default is 31.
    /// </summary>
    public TerraformValue<double>? CoolingThresholdDays
    {
        get => new TerraformReference<double>(this, "cooling_threshold_days");
        set => SetArgument("cooling_threshold_days", value);
    }

    /// <summary>
    /// Optional. Flag indicating that the hot tier bypass mode is enabled. Default is false.
    /// Only applicable to Flex service level.
    /// </summary>
    public TerraformValue<bool>? HotTierBypassModeEnabled
    {
        get => new TerraformReference<bool>(this, "hot_tier_bypass_mode_enabled");
        set => SetArgument("hot_tier_bypass_mode_enabled", value);
    }

    /// <summary>
    /// Optional. Flag indicating if the volume has tiering policy enable/pause. Default is PAUSED. Default value: &amp;quot;PAUSED&amp;quot; Possible values: [&amp;quot;ENABLED&amp;quot;, &amp;quot;PAUSED&amp;quot;]
    /// </summary>
    public TerraformValue<string>? TierAction
    {
        get => new TerraformReference<string>(this, "tier_action");
        set => SetArgument("tier_action", value);
    }

}


/// <summary>
/// Block type for timeouts in GoogleNetappVolume.
/// Nesting mode: single
/// </summary>
public class GoogleNetappVolumeTimeoutsBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "timeouts";

    /// <summary>
    /// The create attribute.
    /// </summary>
    public TerraformValue<string>? Create
    {
        get => new TerraformReference<string>(this, "create");
        set => SetArgument("create", value);
    }

    /// <summary>
    /// The delete attribute.
    /// </summary>
    public TerraformValue<string>? Delete
    {
        get => new TerraformReference<string>(this, "delete");
        set => SetArgument("delete", value);
    }

    /// <summary>
    /// The update attribute.
    /// </summary>
    public TerraformValue<string>? Update
    {
        get => new TerraformReference<string>(this, "update");
        set => SetArgument("update", value);
    }

}


/// <summary>
/// Represents a google_netapp_volume Terraform resource.
/// Manages a google_netapp_volume resource.
/// </summary>
public partial class GoogleNetappVolume(string name) : TerraformResource("google_netapp_volume", name)
{
    /// <summary>
    /// Capacity of the volume (in GiB).
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "CapacityGib is required")]
    public required TerraformValue<string> CapacityGib
    {
        get => new TerraformReference<string>(this, "capacity_gib");
        set => SetArgument("capacity_gib", value);
    }

    /// <summary>
    /// Policy to determine if the volume should be deleted forcefully.
    /// Volumes may have nested snapshot resources. Deleting such a volume will fail.
    /// Setting this parameter to FORCE will delete volumes including nested snapshots.
    /// Possible values: DEFAULT, FORCE.
    /// </summary>
    public TerraformValue<string>? DeletionPolicy
    {
        get => new TerraformReference<string>(this, "deletion_policy");
        set => SetArgument("deletion_policy", value);
    }

    /// <summary>
    /// An optional description of this resource.
    /// </summary>
    public TerraformValue<string>? Description
    {
        get => new TerraformReference<string>(this, "description");
        set => SetArgument("description", value);
    }

    /// <summary>
    /// The id attribute.
    /// </summary>
    public TerraformValue<string> Id
    {
        get => new TerraformReference<string>(this, "id");
        set => SetArgument("id", value);
    }

    /// <summary>
    /// Flag indicating if the volume is a kerberos volume or not, export policy rules control kerberos security modes (krb5, krb5i, krb5p).
    /// </summary>
    public TerraformValue<bool>? KerberosEnabled
    {
        get => new TerraformReference<bool>(this, "kerberos_enabled");
        set => SetArgument("kerberos_enabled", value);
    }

    /// <summary>
    /// Labels as key value pairs. Example: &#39;{ &amp;quot;owner&amp;quot;: &amp;quot;Bob&amp;quot;, &amp;quot;department&amp;quot;: &amp;quot;finance&amp;quot;, &amp;quot;purpose&amp;quot;: &amp;quot;testing&amp;quot; }&#39;.
    /// 
    /// 
    /// **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
    /// Please refer to the field &#39;effective_labels&#39; for all of the labels present on the resource.
    /// </summary>
    public TerraformMap<string>? Labels
    {
        get => TerraformMap<string>.Lazy(ctx => new TerraformReference<TerraformMap<string>>(this, "labels").ResolveNodes(ctx));
        set => SetArgument("labels", value);
    }

    /// <summary>
    /// Optional. Flag indicating if the volume will be a large capacity volume or a regular volume.
    /// </summary>
    public TerraformValue<bool>? LargeCapacity
    {
        get => new TerraformReference<bool>(this, "large_capacity");
        set => SetArgument("large_capacity", value);
    }

    /// <summary>
    /// Name of the pool location. Usually a region name, expect for some STANDARD service level pools which require a zone name.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Location is required")]
    public required TerraformValue<string> Location
    {
        get => new TerraformReference<string>(this, "location");
        set => SetArgument("location", value);
    }

    /// <summary>
    /// Optional. Flag indicating if the volume will have an IP address per node for volumes supporting multiple IP endpoints.
    /// Only the volume with largeCapacity will be allowed to have multiple endpoints.
    /// </summary>
    public TerraformValue<bool>? MultipleEndpoints
    {
        get => new TerraformReference<bool>(this, "multiple_endpoints");
        set => SetArgument("multiple_endpoints", value);
    }

    /// <summary>
    /// The name of the volume. Needs to be unique per location.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Name is required")]
    public required TerraformValue<string> Name
    {
        get => new TerraformReference<string>(this, "name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// The project attribute.
    /// </summary>
    public TerraformValue<string> Project
    {
        get => new TerraformReference<string>(this, "project");
        set => SetArgument("project", value);
    }

    /// <summary>
    /// The protocol of the volume. Allowed combinations are &#39;[&#39;NFSV3&#39;]&#39;, &#39;[&#39;NFSV4&#39;]&#39;, &#39;[&#39;SMB&#39;]&#39;, &#39;[&#39;NFSV3&#39;, &#39;NFSV4&#39;]&#39;, &#39;[&#39;SMB&#39;, &#39;NFSV3&#39;]&#39; and &#39;[&#39;SMB&#39;, &#39;NFSV4&#39;]&#39;. Possible values: [&amp;quot;NFSV3&amp;quot;, &amp;quot;NFSV4&amp;quot;, &amp;quot;SMB&amp;quot;, &amp;quot;ISCSI&amp;quot;]
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Protocols is required")]
    public TerraformList<string>? Protocols
    {
        get => TerraformList<string>.Lazy(ctx => new TerraformReference<TerraformList<string>>(this, "protocols").ResolveNodes(ctx));
        set => SetArgument("protocols", value);
    }

    /// <summary>
    /// List of actions that are restricted on this volume. Possible values: [&amp;quot;DELETE&amp;quot;]
    /// </summary>
    public TerraformList<string>? RestrictedActions
    {
        get => TerraformList<string>.Lazy(ctx => new TerraformReference<TerraformList<string>>(this, "restricted_actions").ResolveNodes(ctx));
        set => SetArgument("restricted_actions", value);
    }

    /// <summary>
    /// Security Style of the Volume. Use UNIX to use UNIX or NFSV4 ACLs for file permissions.
    /// Use NTFS to use NTFS ACLs for file permissions. Can only be set for volumes which use SMB together with NFS as protocol. Possible values: [&amp;quot;NTFS&amp;quot;, &amp;quot;UNIX&amp;quot;]
    /// </summary>
    public TerraformValue<string> SecurityStyle
    {
        get => new TerraformReference<string>(this, "security_style");
        set => SetArgument("security_style", value);
    }

    /// <summary>
    /// Share name (SMB) or export path (NFS) of the volume. Needs to be unique per location.
    /// </summary>
    public TerraformValue<string>? ShareName
    {
        get => new TerraformReference<string>(this, "share_name");
        set => SetArgument("share_name", value);
    }

    /// <summary>
    /// Settings for volumes with SMB access. Possible values: [&amp;quot;ENCRYPT_DATA&amp;quot;, &amp;quot;BROWSABLE&amp;quot;, &amp;quot;CHANGE_NOTIFY&amp;quot;, &amp;quot;NON_BROWSABLE&amp;quot;, &amp;quot;OPLOCKS&amp;quot;, &amp;quot;SHOW_SNAPSHOT&amp;quot;, &amp;quot;SHOW_PREVIOUS_VERSIONS&amp;quot;, &amp;quot;ACCESS_BASED_ENUMERATION&amp;quot;, &amp;quot;CONTINUOUSLY_AVAILABLE&amp;quot;]
    /// </summary>
    public TerraformList<string> SmbSettings
    {
        get => TerraformList<string>.Lazy(ctx => new TerraformReference<TerraformList<string>>(this, "smb_settings").ResolveNodes(ctx));
        set => SetArgument("smb_settings", value);
    }

    /// <summary>
    /// If enabled, a NFS volume will contain a read-only .snapshot directory which provides access to each of the volume&#39;s snapshots. Will enable &amp;quot;Previous Versions&amp;quot; support for SMB.
    /// </summary>
    public TerraformValue<bool>? SnapshotDirectory
    {
        get => new TerraformReference<bool>(this, "snapshot_directory");
        set => SetArgument("snapshot_directory", value);
    }

    /// <summary>
    /// Name of the storage pool to create the volume in. Pool needs enough spare capacity to accommodate the volume.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "StoragePool is required")]
    public required TerraformValue<string> StoragePool
    {
        get => new TerraformReference<string>(this, "storage_pool");
        set => SetArgument("storage_pool", value);
    }

    /// <summary>
    /// Optional. Custom Performance Total Throughput of the pool (in MiB/s).
    /// </summary>
    public TerraformValue<double> ThroughputMibps
    {
        get => new TerraformReference<double>(this, "throughput_mibps");
        set => SetArgument("throughput_mibps", value);
    }

    /// <summary>
    /// Unix permission the mount point will be created with. Default is 0770. Applicable for UNIX security style volumes only.
    /// </summary>
    public TerraformValue<string> UnixPermissions
    {
        get => new TerraformReference<string>(this, "unix_permissions");
        set => SetArgument("unix_permissions", value);
    }

    /// <summary>
    /// Reports the resource name of the Active Directory policy being used. Inherited from storage pool.
    /// </summary>
    public TerraformValue<string> ActiveDirectory
    {
        get => new TerraformReference<string>(this, "active_directory");
    }

    /// <summary>
    /// Output only. Size of the volume cold tier data in GiB.
    /// </summary>
    public TerraformValue<string> ColdTierSizeGib
    {
        get => new TerraformReference<string>(this, "cold_tier_size_gib");
    }

    /// <summary>
    /// Create time of the volume. A timestamp in RFC3339 UTC &amp;quot;Zulu&amp;quot; format. Examples: &amp;quot;2023-06-22T09:13:01.617Z&amp;quot;.
    /// </summary>
    public TerraformValue<string> CreateTime
    {
        get => new TerraformReference<string>(this, "create_time");
    }

    /// <summary>
    /// All of labels (key/value pairs) present on the resource in GCP, including the labels configured through Terraform, other clients and services.
    /// </summary>
    public TerraformMap<string> EffectiveLabels
    {
        get => TerraformMap<string>.Lazy(ctx => new TerraformReference<TerraformMap<string>>(this, "effective_labels").ResolveNodes(ctx));
    }

    /// <summary>
    /// Reports the data-at-rest encryption type of the volume. Inherited from storage pool.
    /// </summary>
    public TerraformValue<string> EncryptionType
    {
        get => new TerraformReference<string>(this, "encryption_type");
    }

    /// <summary>
    /// Indicates whether the volume is part of a volume replication relationship.
    /// </summary>
    public TerraformValue<bool> HasReplication
    {
        get => new TerraformReference<bool>(this, "has_replication");
    }

    /// <summary>
    /// Total hot tier data rounded down to the nearest GiB used by the volume. This field is only used for flex Service Level
    /// </summary>
    public TerraformValue<string> HotTierSizeUsedGib
    {
        get => new TerraformReference<string>(this, "hot_tier_size_used_gib");
    }

    /// <summary>
    /// Reports the CMEK policy resurce name being used for volume encryption. Inherited from storage pool.
    /// </summary>
    public TerraformValue<string> KmsConfig
    {
        get => new TerraformReference<string>(this, "kms_config");
    }

    /// <summary>
    /// Flag indicating if the volume is NFS LDAP enabled or not. Inherited from storage pool.
    /// </summary>
    public TerraformValue<bool> LdapEnabled
    {
        get => new TerraformReference<bool>(this, "ldap_enabled");
    }

    /// <summary>
    /// Reports mount instructions for this volume.
    /// </summary>
    public TerraformList<TerraformMap<object>> MountOptions
    {
        get => TerraformList<TerraformMap<object>>.Lazy(ctx => new TerraformReference<TerraformList<TerraformMap<object>>>(this, "mount_options").ResolveNodes(ctx));
    }

    /// <summary>
    /// VPC network name with format: &#39;projects/{{project}}/global/networks/{{network}}&#39;. Inherited from storage pool.
    /// </summary>
    public TerraformValue<string> Network
    {
        get => new TerraformReference<string>(this, "network");
    }

    /// <summary>
    /// Name of the Private Service Access allocated range. Inherited from storage pool.
    /// </summary>
    public TerraformValue<string> PsaRange
    {
        get => new TerraformReference<string>(this, "psa_range");
    }

    /// <summary>
    /// Specifies the replica zone for regional volume.
    /// </summary>
    public TerraformValue<string> ReplicaZone
    {
        get => new TerraformReference<string>(this, "replica_zone");
    }

    /// <summary>
    /// Service level of the volume. Inherited from storage pool. Supported values are : PREMIUM, EXTREME, STANDARD, FLEX.
    /// </summary>
    public TerraformValue<string> ServiceLevel
    {
        get => new TerraformReference<string>(this, "service_level");
    }

    /// <summary>
    /// State of the volume.
    /// </summary>
    public TerraformValue<string> State
    {
        get => new TerraformReference<string>(this, "state");
    }

    /// <summary>
    /// State details of the volume.
    /// </summary>
    public TerraformValue<string> StateDetails
    {
        get => new TerraformReference<string>(this, "state_details");
    }

    /// <summary>
    /// The combination of labels configured directly on the resource
    ///  and default labels configured on the provider.
    /// </summary>
    public TerraformMap<string> TerraformLabels
    {
        get => TerraformMap<string>.Lazy(ctx => new TerraformReference<TerraformMap<string>>(this, "terraform_labels").ResolveNodes(ctx));
    }

    /// <summary>
    /// Used capacity of the volume (in GiB). This is computed periodically and it does not represent the realtime usage.
    /// </summary>
    public TerraformValue<string> UsedGib
    {
        get => new TerraformReference<string>(this, "used_gib");
    }

    /// <summary>
    /// Specifies the active zone for regional volume.
    /// </summary>
    public TerraformValue<string> Zone
    {
        get => new TerraformReference<string>(this, "zone");
    }

    /// <summary>
    /// BackupConfig block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 BackupConfig block(s) allowed")]
    public TerraformList<GoogleNetappVolumeBackupConfigBlock>? BackupConfig
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeBackupConfigBlock>>("backup_config");
        set => SetArgument("backup_config", value);
    }

    /// <summary>
    /// BlockDevices block (nesting mode: list).
    /// </summary>
    public TerraformList<GoogleNetappVolumeBlockDevicesBlock>? BlockDevices
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeBlockDevicesBlock>>("block_devices");
        set => SetArgument("block_devices", value);
    }

    /// <summary>
    /// ExportPolicy block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 ExportPolicy block(s) allowed")]
    public TerraformList<GoogleNetappVolumeExportPolicyBlock>? ExportPolicy
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeExportPolicyBlock>>("export_policy");
        set => SetArgument("export_policy", value);
    }

    /// <summary>
    /// HybridReplicationParameters block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 HybridReplicationParameters block(s) allowed")]
    public TerraformList<GoogleNetappVolumeHybridReplicationParametersBlock>? HybridReplicationParameters
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeHybridReplicationParametersBlock>>("hybrid_replication_parameters");
        set => SetArgument("hybrid_replication_parameters", value);
    }

    /// <summary>
    /// RestoreParameters block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 RestoreParameters block(s) allowed")]
    public TerraformList<GoogleNetappVolumeRestoreParametersBlock>? RestoreParameters
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeRestoreParametersBlock>>("restore_parameters");
        set => SetArgument("restore_parameters", value);
    }

    /// <summary>
    /// SnapshotPolicy block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 SnapshotPolicy block(s) allowed")]
    public TerraformList<GoogleNetappVolumeSnapshotPolicyBlock>? SnapshotPolicy
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeSnapshotPolicyBlock>>("snapshot_policy");
        set => SetArgument("snapshot_policy", value);
    }

    /// <summary>
    /// TieringPolicy block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 TieringPolicy block(s) allowed")]
    public TerraformList<GoogleNetappVolumeTieringPolicyBlock>? TieringPolicy
    {
        get => GetArgument<TerraformList<GoogleNetappVolumeTieringPolicyBlock>>("tiering_policy");
        set => SetArgument("tiering_policy", value);
    }

    /// <summary>
    /// Timeouts block (nesting mode: single).
    /// </summary>
    public GoogleNetappVolumeTimeoutsBlock? Timeouts
    {
        get => GetArgument<GoogleNetappVolumeTimeoutsBlock>("timeouts");
        set => SetArgument("timeouts", value);
    }

}
