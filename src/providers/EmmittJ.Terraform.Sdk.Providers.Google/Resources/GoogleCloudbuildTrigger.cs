using EmmittJ.Terraform.Sdk;

namespace EmmittJ.Terraform.Sdk.Providers.Google;

/// <summary>
/// Block type for approval_config in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerApprovalConfigBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "approval_config";

    /// <summary>
    /// Whether or not approval is needed. If this is set on a build, it will become pending when run,
    /// and will need to be explicitly approved to start.
    /// </summary>
    public TerraformValue<bool>? ApprovalRequired
    {
        get => GetArgument<TerraformValue<bool>>("approval_required");
        set => SetArgument("approval_required", value);
    }

}


/// <summary>
/// Block type for bitbucket_server_trigger_config in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "bitbucket_server_trigger_config";

    /// <summary>
    /// The Bitbucket server config resource that this trigger config maps to.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "BitbucketServerConfigResource is required")]
    public required TerraformValue<string> BitbucketServerConfigResource
    {
        get => GetRequiredArgument<TerraformValue<string>>("bitbucket_server_config_resource");
        set => SetArgument("bitbucket_server_config_resource", value);
    }

    /// <summary>
    /// Key of the project that the repo is in. For example: The key for https://mybitbucket.server/projects/TEST/repos/test-repo is &amp;quot;TEST&amp;quot;.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "ProjectKey is required")]
    public required TerraformValue<string> ProjectKey
    {
        get => GetRequiredArgument<TerraformValue<string>>("project_key");
        set => SetArgument("project_key", value);
    }

    /// <summary>
    /// Slug of the repository. A repository slug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL.
    /// For example, if the repository name is &#39;test repo&#39;, in the URL it would become &#39;test-repo&#39; as in https://mybitbucket.server/projects/TEST/repos/test-repo.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "RepoSlug is required")]
    public required TerraformValue<string> RepoSlug
    {
        get => GetRequiredArgument<TerraformValue<string>>("repo_slug");
        set => SetArgument("repo_slug", value);
    }

    /// <summary>
    /// PullRequest block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 PullRequest block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlockPullRequestBlock>? PullRequest
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlockPullRequestBlock>>("pull_request");
        set => SetArgument("pull_request", value);
    }

    /// <summary>
    /// Push block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Push block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlockPushBlock>? Push
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlockPushBlock>>("push");
        set => SetArgument("push", value);
    }

}

/// <summary>
/// Block type for pull_request in GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlockPullRequestBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "pull_request";

    /// <summary>
    /// Regex of branches to match.
    /// The syntax of the regular expressions accepted is the syntax accepted by RE2 and described at https://github.com/google/re2/wiki/Syntax
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Branch is required")]
    public required TerraformValue<string> Branch
    {
        get => GetRequiredArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// Configure builds to run whether a repository owner or collaborator need to comment /gcbrun. Possible values: [&amp;quot;COMMENTS_DISABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY&amp;quot;]
    /// </summary>
    public TerraformValue<string>? CommentControl
    {
        get => GetArgument<TerraformValue<string>>("comment_control");
        set => SetArgument("comment_control", value);
    }

    /// <summary>
    /// If true, branches that do NOT match the git_ref will trigger a build.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

}

/// <summary>
/// Block type for push in GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlockPushBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "push";

    /// <summary>
    /// Regex of branches to match.  Specify only one of branch or tag.
    /// </summary>
    public TerraformValue<string>? Branch
    {
        get => GetArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// When true, only trigger a build if the revision regex does NOT match the gitRef regex.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

    /// <summary>
    /// Regex of tags to match.  Specify only one of branch or tag.
    /// </summary>
    public TerraformValue<string>? Tag
    {
        get => GetArgument<TerraformValue<string>>("tag");
        set => SetArgument("tag", value);
    }

}


/// <summary>
/// Block type for build in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "build";

    /// <summary>
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// The images are pushed using the builder service account&#39;s credentials.
    /// The digests of the pushed images will be stored in the Build resource&#39;s results field.
    /// If any of the images fail to be pushed, the build status is marked FAILURE.
    /// </summary>
    public TerraformList<string>? Images
    {
        get => GetArgument<TerraformList<string>>("images");
        set => SetArgument("images", value);
    }

    /// <summary>
    /// Google Cloud Storage bucket where logs should be written.
    /// Logs file names will be of the format ${logsBucket}/log-${build_id}.txt.
    /// </summary>
    public TerraformValue<string>? LogsBucket
    {
        get => GetArgument<TerraformValue<string>>("logs_bucket");
        set => SetArgument("logs_bucket", value);
    }

    /// <summary>
    /// TTL in queue for this build. If provided and the build is enqueued longer than this value,
    /// the build will expire and the build status will be EXPIRED.
    /// The TTL starts ticking from createTime.
    /// A duration in seconds with up to nine fractional digits, terminated by &#39;s&#39;. Example: &amp;quot;3.5s&amp;quot;.
    /// </summary>
    public TerraformValue<string>? QueueTtl
    {
        get => GetArgument<TerraformValue<string>>("queue_ttl");
        set => SetArgument("queue_ttl", value);
    }

    /// <summary>
    /// Substitutions data for Build resource.
    /// </summary>
    public TerraformMap<string>? Substitutions
    {
        get => GetArgument<TerraformMap<string>>("substitutions");
        set => SetArgument("substitutions", value);
    }

    /// <summary>
    /// Tags for annotation of a Build. These are not docker tags.
    /// </summary>
    public TerraformList<string>? Tags
    {
        get => GetArgument<TerraformList<string>>("tags");
        set => SetArgument("tags", value);
    }

    /// <summary>
    /// Amount of time that this build should be allowed to run, to second granularity.
    /// If this amount of time elapses, work on the build will cease and the build status will be TIMEOUT.
    /// This timeout must be equal to or greater than the sum of the timeouts for build steps within the build.
    /// The expected format is the number of seconds followed by s.
    /// Default time is ten minutes (600s).
    /// </summary>
    public TerraformValue<string>? Timeout
    {
        get => GetArgument<TerraformValue<string>>("timeout");
        set => SetArgument("timeout", value);
    }

    /// <summary>
    /// Artifacts block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Artifacts block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlock>? Artifacts
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlock>>("artifacts");
        set => SetArgument("artifacts", value);
    }

    /// <summary>
    /// AvailableSecrets block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 AvailableSecrets block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlockAvailableSecretsBlock>? AvailableSecrets
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockAvailableSecretsBlock>>("available_secrets");
        set => SetArgument("available_secrets", value);
    }

    /// <summary>
    /// Options block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Options block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlockOptionsBlock>? Options
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockOptionsBlock>>("options");
        set => SetArgument("options", value);
    }

    /// <summary>
    /// Secret block (nesting mode: list).
    /// </summary>
    public TerraformList<GoogleCloudbuildTriggerBuildBlockSecretBlock>? Secret
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockSecretBlock>>("secret");
        set => SetArgument("secret", value);
    }

    /// <summary>
    /// Source block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Source block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlockSourceBlock>? Source
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockSourceBlock>>("source");
        set => SetArgument("source", value);
    }

    /// <summary>
    /// Step block (nesting mode: list).
    /// This block is required.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Step is required")]
    [System.ComponentModel.DataAnnotations.MinLength(1, ErrorMessage = "At least 1 Step block(s) required")]
    public required TerraformList<GoogleCloudbuildTriggerBuildBlockStepBlock> Step
    {
        get => GetRequiredArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockStepBlock>>("step");
        set => SetArgument("step", value);
    }

}

/// <summary>
/// Block type for artifacts in GoogleCloudbuildTriggerBuildBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockArtifactsBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "artifacts";

    /// <summary>
    /// A list of images to be pushed upon the successful completion of all build steps.
    /// 
    /// The images will be pushed using the builder service account&#39;s credentials.
    /// 
    /// The digests of the pushed images will be stored in the Build resource&#39;s results field.
    /// 
    /// If any of the images fail to be pushed, the build is marked FAILURE.
    /// </summary>
    public TerraformList<string>? Images
    {
        get => GetArgument<TerraformList<string>>("images");
        set => SetArgument("images", value);
    }

    /// <summary>
    /// MavenArtifacts block (nesting mode: list).
    /// </summary>
    public TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockMavenArtifactsBlock>? MavenArtifacts
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockMavenArtifactsBlock>>("maven_artifacts");
        set => SetArgument("maven_artifacts", value);
    }

    /// <summary>
    /// NpmPackages block (nesting mode: list).
    /// </summary>
    public TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockNpmPackagesBlock>? NpmPackages
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockNpmPackagesBlock>>("npm_packages");
        set => SetArgument("npm_packages", value);
    }

    /// <summary>
    /// Objects block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Objects block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockObjectsBlock>? Objects
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockObjectsBlock>>("objects");
        set => SetArgument("objects", value);
    }

    /// <summary>
    /// PythonPackages block (nesting mode: list).
    /// </summary>
    public TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockPythonPackagesBlock>? PythonPackages
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockArtifactsBlockPythonPackagesBlock>>("python_packages");
        set => SetArgument("python_packages", value);
    }

}

/// <summary>
/// Block type for maven_artifacts in GoogleCloudbuildTriggerBuildBlockArtifactsBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockArtifactsBlockMavenArtifactsBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "maven_artifacts";

    /// <summary>
    /// Maven artifactId value used when uploading the artifact to Artifact Registry.
    /// </summary>
    public TerraformValue<string>? ArtifactId
    {
        get => GetArgument<TerraformValue<string>>("artifact_id");
        set => SetArgument("artifact_id", value);
    }

    /// <summary>
    /// Maven groupId value used when uploading the artifact to Artifact Registry.
    /// </summary>
    public TerraformValue<string>? GroupId
    {
        get => GetArgument<TerraformValue<string>>("group_id");
        set => SetArgument("group_id", value);
    }

    /// <summary>
    /// Path to an artifact in the build&#39;s workspace to be uploaded to Artifact Registry. This can be either an absolute path, e.g. /workspace/my-app/target/my-app-1.0.SNAPSHOT.jar or a relative path from /workspace, e.g. my-app/target/my-app-1.0.SNAPSHOT.jar.
    /// </summary>
    public TerraformValue<string>? Path
    {
        get => GetArgument<TerraformValue<string>>("path");
        set => SetArgument("path", value);
    }

    /// <summary>
    /// Artifact Registry repository, in the form &amp;quot;https://$REGION-maven.pkg.dev/$PROJECT/$REPOSITORY&amp;quot;
    /// 
    /// Artifact in the workspace specified by path will be uploaded to Artifact Registry with this location as a prefix.
    /// </summary>
    public TerraformValue<string>? Repository
    {
        get => GetArgument<TerraformValue<string>>("repository");
        set => SetArgument("repository", value);
    }

    /// <summary>
    /// Maven version value used when uploading the artifact to Artifact Registry.
    /// </summary>
    public TerraformValue<string>? Version
    {
        get => GetArgument<TerraformValue<string>>("version");
        set => SetArgument("version", value);
    }

}

/// <summary>
/// Block type for npm_packages in GoogleCloudbuildTriggerBuildBlockArtifactsBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockArtifactsBlockNpmPackagesBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "npm_packages";

    /// <summary>
    /// Path to the package.json. e.g. workspace/path/to/package
    /// </summary>
    public TerraformValue<string>? PackagePath
    {
        get => GetArgument<TerraformValue<string>>("package_path");
        set => SetArgument("package_path", value);
    }

    /// <summary>
    /// Artifact Registry repository, in the form &amp;quot;https://$REGION-npm.pkg.dev/$PROJECT/$REPOSITORY&amp;quot;
    /// 
    /// Npm package in the workspace specified by path will be zipped and uploaded to Artifact Registry with this location as a prefix.
    /// </summary>
    public TerraformValue<string>? Repository
    {
        get => GetArgument<TerraformValue<string>>("repository");
        set => SetArgument("repository", value);
    }

}

/// <summary>
/// Block type for objects in GoogleCloudbuildTriggerBuildBlockArtifactsBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockArtifactsBlockObjectsBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "objects";

    /// <summary>
    /// Cloud Storage bucket and optional object path, in the form &amp;quot;gs://bucket/path/to/somewhere/&amp;quot;.
    /// 
    /// Files in the workspace matching any path pattern will be uploaded to Cloud Storage with
    /// this location as a prefix.
    /// </summary>
    public TerraformValue<string>? Location
    {
        get => GetArgument<TerraformValue<string>>("location");
        set => SetArgument("location", value);
    }

    /// <summary>
    /// Path globs used to match files in the build&#39;s workspace.
    /// </summary>
    public TerraformList<string>? Paths
    {
        get => GetArgument<TerraformList<string>>("paths");
        set => SetArgument("paths", value);
    }

    /// <summary>
    /// Output only. Stores timing information for pushing all artifact objects.
    /// </summary>
    public TerraformList<TerraformMap<object>> Timing
        => CreateReference("timing");

}

/// <summary>
/// Block type for python_packages in GoogleCloudbuildTriggerBuildBlockArtifactsBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockArtifactsBlockPythonPackagesBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "python_packages";

    /// <summary>
    /// Path globs used to match files in the build&#39;s workspace. For Python/ Twine, this is usually dist/*, and sometimes additionally an .asc file.
    /// </summary>
    public TerraformList<string>? Paths
    {
        get => GetArgument<TerraformList<string>>("paths");
        set => SetArgument("paths", value);
    }

    /// <summary>
    /// Artifact Registry repository, in the form &amp;quot;https://$REGION-python.pkg.dev/$PROJECT/$REPOSITORY&amp;quot;
    /// 
    /// Files in the workspace matching any path pattern will be uploaded to Artifact Registry with this location as a prefix.
    /// </summary>
    public TerraformValue<string>? Repository
    {
        get => GetArgument<TerraformValue<string>>("repository");
        set => SetArgument("repository", value);
    }

}

/// <summary>
/// Block type for available_secrets in GoogleCloudbuildTriggerBuildBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockAvailableSecretsBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "available_secrets";

    /// <summary>
    /// SecretManager block (nesting mode: list).
    /// This block is required.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "SecretManager is required")]
    [System.ComponentModel.DataAnnotations.MinLength(1, ErrorMessage = "At least 1 SecretManager block(s) required")]
    public required TerraformList<GoogleCloudbuildTriggerBuildBlockAvailableSecretsBlockSecretManagerBlock> SecretManager
    {
        get => GetRequiredArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockAvailableSecretsBlockSecretManagerBlock>>("secret_manager");
        set => SetArgument("secret_manager", value);
    }

}

/// <summary>
/// Block type for secret_manager in GoogleCloudbuildTriggerBuildBlockAvailableSecretsBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockAvailableSecretsBlockSecretManagerBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "secret_manager";

    /// <summary>
    /// Environment variable name to associate with the secret. Secret environment
    /// variables must be unique across all of a build&#39;s secrets, and must be used
    /// by at least one build step.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Env is required")]
    public required TerraformValue<string> Env
    {
        get => GetRequiredArgument<TerraformValue<string>>("env");
        set => SetArgument("env", value);
    }

    /// <summary>
    /// Resource name of the SecretVersion. In format: projects/*/secrets/*/versions/*
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "VersionName is required")]
    public required TerraformValue<string> VersionName
    {
        get => GetRequiredArgument<TerraformValue<string>>("version_name");
        set => SetArgument("version_name", value);
    }

}

/// <summary>
/// Block type for options in GoogleCloudbuildTriggerBuildBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockOptionsBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "options";

    /// <summary>
    /// Requested disk size for the VM that runs the build. Note that this is NOT &amp;quot;disk free&amp;quot;;
    /// some of the space will be used by the operating system and build utilities.
    /// Also note that this is the minimum disk size that will be allocated for the build --
    /// the build may run with a larger disk than requested. At present, the maximum disk size
    /// is 1000GB; builds that request more than the maximum are rejected with an error.
    /// </summary>
    public TerraformValue<double>? DiskSizeGb
    {
        get => GetArgument<TerraformValue<double>>("disk_size_gb");
        set => SetArgument("disk_size_gb", value);
    }

    /// <summary>
    /// Option to specify whether or not to apply bash style string operations to the substitutions.
    /// 
    /// NOTE this is always enabled for triggered builds and cannot be overridden in the build configuration file.
    /// </summary>
    public TerraformValue<bool>? DynamicSubstitutions
    {
        get => GetArgument<TerraformValue<bool>>("dynamic_substitutions");
        set => SetArgument("dynamic_substitutions", value);
    }

    /// <summary>
    /// A list of global environment variable definitions that will exist for all build steps
    /// in this build. If a variable is defined in both globally and in a build step,
    /// the variable will use the build step value.
    /// 
    /// The elements are of the form &amp;quot;KEY=VALUE&amp;quot; for the environment variable &amp;quot;KEY&amp;quot; being given the value &amp;quot;VALUE&amp;quot;.
    /// </summary>
    public TerraformList<string>? Env
    {
        get => GetArgument<TerraformList<string>>("env");
        set => SetArgument("env", value);
    }

    /// <summary>
    /// Option to define build log streaming behavior to Google Cloud Storage. Possible values: [&amp;quot;STREAM_DEFAULT&amp;quot;, &amp;quot;STREAM_ON&amp;quot;, &amp;quot;STREAM_OFF&amp;quot;]
    /// </summary>
    public TerraformValue<string>? LogStreamingOption
    {
        get => GetArgument<TerraformValue<string>>("log_streaming_option");
        set => SetArgument("log_streaming_option", value);
    }

    /// <summary>
    /// Option to specify the logging mode, which determines if and where build logs are stored. Possible values: [&amp;quot;LOGGING_UNSPECIFIED&amp;quot;, &amp;quot;LEGACY&amp;quot;, &amp;quot;GCS_ONLY&amp;quot;, &amp;quot;STACKDRIVER_ONLY&amp;quot;, &amp;quot;CLOUD_LOGGING_ONLY&amp;quot;, &amp;quot;NONE&amp;quot;]
    /// </summary>
    public TerraformValue<string>? Logging
    {
        get => GetArgument<TerraformValue<string>>("logging");
        set => SetArgument("logging", value);
    }

    /// <summary>
    /// Compute Engine machine type on which to run the build.
    /// </summary>
    public TerraformValue<string>? MachineType
    {
        get => GetArgument<TerraformValue<string>>("machine_type");
        set => SetArgument("machine_type", value);
    }

    /// <summary>
    /// Requested verifiability options. Possible values: [&amp;quot;NOT_VERIFIED&amp;quot;, &amp;quot;VERIFIED&amp;quot;]
    /// </summary>
    public TerraformValue<string>? RequestedVerifyOption
    {
        get => GetArgument<TerraformValue<string>>("requested_verify_option");
        set => SetArgument("requested_verify_option", value);
    }

    /// <summary>
    /// A list of global environment variables, which are encrypted using a Cloud Key Management
    /// Service crypto key. These values must be specified in the build&#39;s Secret. These variables
    /// will be available to all build steps in this build.
    /// </summary>
    public TerraformList<string>? SecretEnv
    {
        get => GetArgument<TerraformList<string>>("secret_env");
        set => SetArgument("secret_env", value);
    }

    /// <summary>
    /// Requested hash for SourceProvenance. Possible values: [&amp;quot;NONE&amp;quot;, &amp;quot;SHA256&amp;quot;, &amp;quot;MD5&amp;quot;]
    /// </summary>
    public TerraformList<string>? SourceProvenanceHash
    {
        get => GetArgument<TerraformList<string>>("source_provenance_hash");
        set => SetArgument("source_provenance_hash", value);
    }

    /// <summary>
    /// Option to specify behavior when there is an error in the substitution checks.
    /// 
    /// NOTE this is always set to ALLOW_LOOSE for triggered builds and cannot be overridden
    /// in the build configuration file. Possible values: [&amp;quot;MUST_MATCH&amp;quot;, &amp;quot;ALLOW_LOOSE&amp;quot;]
    /// </summary>
    public TerraformValue<string>? SubstitutionOption
    {
        get => GetArgument<TerraformValue<string>>("substitution_option");
        set => SetArgument("substitution_option", value);
    }

    /// <summary>
    /// Option to specify a WorkerPool for the build. Format projects/{project}/workerPools/{workerPool}
    /// 
    /// This field is experimental.
    /// </summary>
    public TerraformValue<string>? WorkerPool
    {
        get => GetArgument<TerraformValue<string>>("worker_pool");
        set => SetArgument("worker_pool", value);
    }

    /// <summary>
    /// Volumes block (nesting mode: list).
    /// </summary>
    public TerraformList<GoogleCloudbuildTriggerBuildBlockOptionsBlockVolumesBlock>? Volumes
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockOptionsBlockVolumesBlock>>("volumes");
        set => SetArgument("volumes", value);
    }

}

/// <summary>
/// Block type for volumes in GoogleCloudbuildTriggerBuildBlockOptionsBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockOptionsBlockVolumesBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "volumes";

    /// <summary>
    /// Name of the volume to mount.
    /// 
    /// Volume names must be unique per build step and must be valid names for Docker volumes.
    /// Each named volume must be used by at least two build steps.
    /// </summary>
    public TerraformValue<string>? Name
    {
        get => GetArgument<TerraformValue<string>>("name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// Path at which to mount the volume.
    /// 
    /// Paths must be absolute and cannot conflict with other volume paths on the same
    /// build step or with certain reserved volume paths.
    /// </summary>
    public TerraformValue<string>? Path
    {
        get => GetArgument<TerraformValue<string>>("path");
        set => SetArgument("path", value);
    }

}

/// <summary>
/// Block type for secret in GoogleCloudbuildTriggerBuildBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockSecretBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "secret";

    /// <summary>
    /// Cloud KMS key name to use to decrypt these envs.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "KmsKeyName is required")]
    public required TerraformValue<string> KmsKeyName
    {
        get => GetRequiredArgument<TerraformValue<string>>("kms_key_name");
        set => SetArgument("kms_key_name", value);
    }

    /// <summary>
    /// Map of environment variable name to its encrypted value.
    /// Secret environment variables must be unique across all of a build&#39;s secrets,
    /// and must be used by at least one build step. Values can be at most 64 KB in size.
    /// There can be at most 100 secret values across all of a build&#39;s secrets.
    /// </summary>
    public TerraformMap<string>? SecretEnv
    {
        get => GetArgument<TerraformMap<string>>("secret_env");
        set => SetArgument("secret_env", value);
    }

}

/// <summary>
/// Block type for source in GoogleCloudbuildTriggerBuildBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockSourceBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "source";

    /// <summary>
    /// RepoSource block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 RepoSource block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlockSourceBlockRepoSourceBlock>? RepoSource
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockSourceBlockRepoSourceBlock>>("repo_source");
        set => SetArgument("repo_source", value);
    }

    /// <summary>
    /// StorageSource block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 StorageSource block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlockSourceBlockStorageSourceBlock>? StorageSource
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockSourceBlockStorageSourceBlock>>("storage_source");
        set => SetArgument("storage_source", value);
    }

}

/// <summary>
/// Block type for repo_source in GoogleCloudbuildTriggerBuildBlockSourceBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockSourceBlockRepoSourceBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "repo_source";

    /// <summary>
    /// Regex matching branches to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// The syntax of the regular expressions accepted is the syntax accepted by RE2 and
    /// described at https://github.com/google/re2/wiki/Syntax
    /// </summary>
    public TerraformValue<string>? BranchName
    {
        get => GetArgument<TerraformValue<string>>("branch_name");
        set => SetArgument("branch_name", value);
    }

    /// <summary>
    /// Explicit commit SHA to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// </summary>
    public TerraformValue<string>? CommitSha
    {
        get => GetArgument<TerraformValue<string>>("commit_sha");
        set => SetArgument("commit_sha", value);
    }

    /// <summary>
    /// Directory, relative to the source root, in which to run the build.
    /// This must be a relative path. If a step&#39;s dir is specified and is an absolute path,
    /// this value is ignored for that step&#39;s execution.
    /// </summary>
    public TerraformValue<string>? Dir
    {
        get => GetArgument<TerraformValue<string>>("dir");
        set => SetArgument("dir", value);
    }

    /// <summary>
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

    /// <summary>
    /// ID of the project that owns the Cloud Source Repository.
    /// If omitted, the project ID requesting the build is assumed.
    /// </summary>
    public TerraformValue<string>? ProjectId
    {
        get => GetArgument<TerraformValue<string>>("project_id");
        set => SetArgument("project_id", value);
    }

    /// <summary>
    /// Name of the Cloud Source Repository.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "RepoName is required")]
    public required TerraformValue<string> RepoName
    {
        get => GetRequiredArgument<TerraformValue<string>>("repo_name");
        set => SetArgument("repo_name", value);
    }

    /// <summary>
    /// Substitutions to use in a triggered build. Should only be used with triggers.run
    /// </summary>
    public TerraformMap<string>? Substitutions
    {
        get => GetArgument<TerraformMap<string>>("substitutions");
        set => SetArgument("substitutions", value);
    }

    /// <summary>
    /// Regex matching tags to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// The syntax of the regular expressions accepted is the syntax accepted by RE2 and
    /// described at https://github.com/google/re2/wiki/Syntax
    /// </summary>
    public TerraformValue<string>? TagName
    {
        get => GetArgument<TerraformValue<string>>("tag_name");
        set => SetArgument("tag_name", value);
    }

}

/// <summary>
/// Block type for storage_source in GoogleCloudbuildTriggerBuildBlockSourceBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockSourceBlockStorageSourceBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "storage_source";

    /// <summary>
    /// Google Cloud Storage bucket containing the source.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Bucket is required")]
    public required TerraformValue<string> Bucket
    {
        get => GetRequiredArgument<TerraformValue<string>>("bucket");
        set => SetArgument("bucket", value);
    }

    /// <summary>
    /// Google Cloud Storage generation for the object.
    /// If the generation is omitted, the latest generation will be used
    /// </summary>
    public TerraformValue<string>? Generation
    {
        get => GetArgument<TerraformValue<string>>("generation");
        set => SetArgument("generation", value);
    }

    /// <summary>
    /// Google Cloud Storage object containing the source.
    /// This object must be a gzipped archive file (.tar.gz) containing source to build.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "ObjectAttribute is required")]
    public required TerraformValue<string> ObjectAttribute
    {
        get => GetRequiredArgument<TerraformValue<string>>("object");
        set => SetArgument("object", value);
    }

}

/// <summary>
/// Block type for step in GoogleCloudbuildTriggerBuildBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockStepBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "step";

    /// <summary>
    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes.
    /// 
    /// If &#39;allowFailure&#39; is also specified, this field will take precedence.
    /// </summary>
    public TerraformList<double>? AllowExitCodes
    {
        get => GetArgument<TerraformList<double>>("allow_exit_codes");
        set => SetArgument("allow_exit_codes", value);
    }

    /// <summary>
    /// Allow this build step to fail without failing the entire build.
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the &#39;failureDetail&#39; field.
    /// 
    /// &#39;allowExitCodes&#39; takes precedence over this field.
    /// </summary>
    public TerraformValue<bool>? AllowFailure
    {
        get => GetArgument<TerraformValue<bool>>("allow_failure");
        set => SetArgument("allow_failure", value);
    }

    /// <summary>
    /// A list of arguments that will be presented to the step when it is started.
    /// 
    /// If the image used to run the step&#39;s container has an entrypoint, the args
    /// are used as arguments to that entrypoint. If the image does not define an
    /// entrypoint, the first element in args is used as the entrypoint, and the
    /// remainder will be used as arguments.
    /// </summary>
    public TerraformList<string>? Args
    {
        get => GetArgument<TerraformList<string>>("args");
        set => SetArgument("args", value);
    }

    /// <summary>
    /// Working directory to use when running this step&#39;s container.
    /// 
    /// If this value is a relative path, it is relative to the build&#39;s working
    /// directory. If this value is absolute, it may be outside the build&#39;s working
    /// directory, in which case the contents of the path may not be persisted
    /// across build step executions, unless a &#39;volume&#39; for that path is specified.
    /// 
    /// If the build specifies a &#39;RepoSource&#39; with &#39;dir&#39; and a step with a
    /// &#39;dir&#39;,
    /// which specifies an absolute path, the &#39;RepoSource&#39; &#39;dir&#39; is ignored
    /// for the step&#39;s execution.
    /// </summary>
    public TerraformValue<string>? Dir
    {
        get => GetArgument<TerraformValue<string>>("dir");
        set => SetArgument("dir", value);
    }

    /// <summary>
    /// Entrypoint to be used instead of the build step image&#39;s
    /// default entrypoint.
    /// If unset, the image&#39;s default entrypoint is used
    /// </summary>
    public TerraformValue<string>? Entrypoint
    {
        get => GetArgument<TerraformValue<string>>("entrypoint");
        set => SetArgument("entrypoint", value);
    }

    /// <summary>
    /// A list of environment variable definitions to be used when
    /// running a step.
    /// 
    /// The elements are of the form &amp;quot;KEY=VALUE&amp;quot; for the environment variable
    /// &amp;quot;KEY&amp;quot; being given the value &amp;quot;VALUE&amp;quot;.
    /// </summary>
    public TerraformList<string>? Env
    {
        get => GetArgument<TerraformList<string>>("env");
        set => SetArgument("env", value);
    }

    /// <summary>
    /// Unique identifier for this build step, used in &#39;wait_for&#39; to
    /// reference this build step as a dependency.
    /// </summary>
    public TerraformValue<string>? Id
    {
        get => GetArgument<TerraformValue<string>>("id");
        set => SetArgument("id", value);
    }

    /// <summary>
    /// The name of the container image that will run this particular build step.
    /// 
    /// If the image is available in the host&#39;s Docker daemon&#39;s cache, it will be
    /// run directly. If not, the host will attempt to pull the image first, using
    /// the builder service account&#39;s credentials if necessary.
    /// 
    /// The Docker daemon&#39;s cache will already have the latest versions of all of
    /// the officially supported build steps (see https://github.com/GoogleCloudPlatform/cloud-builders
    /// for images and examples).
    /// The Docker daemon will also have cached many of the layers for some popular
    /// images, like &amp;quot;ubuntu&amp;quot;, &amp;quot;debian&amp;quot;, but they will be refreshed at the time
    /// you attempt to use them.
    /// 
    /// If you built an image in a previous build step, it will be stored in the
    /// host&#39;s Docker daemon&#39;s cache and is available to use as the name for a
    /// later build step.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Name is required")]
    public required TerraformValue<string> Name
    {
        get => GetRequiredArgument<TerraformValue<string>>("name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// A shell script to be executed in the step.
    /// When script is provided, the user cannot specify the entrypoint or args.
    /// </summary>
    public TerraformValue<string>? Script
    {
        get => GetArgument<TerraformValue<string>>("script");
        set => SetArgument("script", value);
    }

    /// <summary>
    /// A list of environment variables which are encrypted using
    /// a Cloud Key
    /// Management Service crypto key. These values must be specified in
    /// the build&#39;s &#39;Secret&#39;.
    /// </summary>
    public TerraformList<string>? SecretEnv
    {
        get => GetArgument<TerraformList<string>>("secret_env");
        set => SetArgument("secret_env", value);
    }

    /// <summary>
    /// Time limit for executing this build step. If not defined,
    /// the step has no
    /// time limit and will be allowed to continue to run until either it
    /// completes or the build itself times out.
    /// </summary>
    public TerraformValue<string>? Timeout
    {
        get => GetArgument<TerraformValue<string>>("timeout");
        set => SetArgument("timeout", value);
    }

    /// <summary>
    /// Output only. Stores timing information for executing this
    /// build step.
    /// </summary>
    public TerraformValue<string>? Timing
    {
        get => GetArgument<TerraformValue<string>>("timing");
        set => SetArgument("timing", value);
    }

    /// <summary>
    /// The ID(s) of the step(s) that this build step depends on.
    /// 
    /// This build step will not start until all the build steps in &#39;wait_for&#39;
    /// have completed successfully. If &#39;wait_for&#39; is empty, this build step
    /// will start when all previous build steps in the &#39;Build.Steps&#39; list
    /// have completed successfully.
    /// </summary>
    public TerraformList<string>? WaitFor
    {
        get => GetArgument<TerraformList<string>>("wait_for");
        set => SetArgument("wait_for", value);
    }

    /// <summary>
    /// Volumes block (nesting mode: list).
    /// </summary>
    public TerraformList<GoogleCloudbuildTriggerBuildBlockStepBlockVolumesBlock>? Volumes
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlockStepBlockVolumesBlock>>("volumes");
        set => SetArgument("volumes", value);
    }

}

/// <summary>
/// Block type for volumes in GoogleCloudbuildTriggerBuildBlockStepBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerBuildBlockStepBlockVolumesBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "volumes";

    /// <summary>
    /// Name of the volume to mount.
    /// 
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Name is required")]
    public required TerraformValue<string> Name
    {
        get => GetRequiredArgument<TerraformValue<string>>("name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// Path at which to mount the volume.
    /// 
    /// Paths must be absolute and cannot conflict with other volume paths on
    /// the same build step or with certain reserved volume paths.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Path is required")]
    public required TerraformValue<string> Path
    {
        get => GetRequiredArgument<TerraformValue<string>>("path");
        set => SetArgument("path", value);
    }

}


/// <summary>
/// Block type for developer_connect_event_config in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerDeveloperConnectEventConfigBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "developer_connect_event_config";

    /// <summary>
    /// The Developer Connect Git repository link, formatted as &#39;projects/*/locations/*/connections/*/gitRepositoryLink/*&#39;.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "GitRepositoryLink is required")]
    public required TerraformValue<string> GitRepositoryLink
    {
        get => GetRequiredArgument<TerraformValue<string>>("git_repository_link");
        set => SetArgument("git_repository_link", value);
    }

    /// <summary>
    /// The type of DeveloperConnect GitRepositoryLink.
    /// </summary>
    public TerraformValue<string> GitRepositoryLinkType
        => CreateReference("git_repository_link_type");

    /// <summary>
    /// PullRequest block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 PullRequest block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerDeveloperConnectEventConfigBlockPullRequestBlock>? PullRequest
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerDeveloperConnectEventConfigBlockPullRequestBlock>>("pull_request");
        set => SetArgument("pull_request", value);
    }

    /// <summary>
    /// Push block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Push block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerDeveloperConnectEventConfigBlockPushBlock>? Push
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerDeveloperConnectEventConfigBlockPushBlock>>("push");
        set => SetArgument("push", value);
    }

}

/// <summary>
/// Block type for pull_request in GoogleCloudbuildTriggerDeveloperConnectEventConfigBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerDeveloperConnectEventConfigBlockPullRequestBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "pull_request";

    /// <summary>
    /// Regex of branches to match.
    /// </summary>
    public TerraformValue<string>? Branch
    {
        get => GetArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// Configure builds to run whether a repository owner or collaborator need to comment &#39;/gcbrun&#39;. Possible values: [&amp;quot;COMMENTS_DISABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY&amp;quot;]
    /// </summary>
    public TerraformValue<string>? CommentControl
    {
        get => GetArgument<TerraformValue<string>>("comment_control");
        set => SetArgument("comment_control", value);
    }

    /// <summary>
    /// If true, branches that do NOT match the git_ref will trigger a build.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

}

/// <summary>
/// Block type for push in GoogleCloudbuildTriggerDeveloperConnectEventConfigBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerDeveloperConnectEventConfigBlockPushBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "push";

    /// <summary>
    /// Regex of branches to match.
    /// </summary>
    public TerraformValue<string>? Branch
    {
        get => GetArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// If true, only trigger a build if the revision regex does NOT match the git_ref regex.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

    /// <summary>
    /// Regex of tags to match.
    /// </summary>
    public TerraformValue<string>? Tag
    {
        get => GetArgument<TerraformValue<string>>("tag");
        set => SetArgument("tag", value);
    }

}


/// <summary>
/// Block type for git_file_source in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerGitFileSourceBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "git_file_source";

    /// <summary>
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    /// </summary>
    public TerraformValue<string>? BitbucketServerConfig
    {
        get => GetArgument<TerraformValue<string>>("bitbucket_server_config");
        set => SetArgument("bitbucket_server_config", value);
    }

    /// <summary>
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    /// </summary>
    public TerraformValue<string>? GithubEnterpriseConfig
    {
        get => GetArgument<TerraformValue<string>>("github_enterprise_config");
        set => SetArgument("github_enterprise_config", value);
    }

    /// <summary>
    /// The path of the file, with the repo root as the root of the path.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Path is required")]
    public required TerraformValue<string> Path
    {
        get => GetRequiredArgument<TerraformValue<string>>("path");
        set => SetArgument("path", value);
    }

    /// <summary>
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER Possible values: [&amp;quot;UNKNOWN&amp;quot;, &amp;quot;CLOUD_SOURCE_REPOSITORIES&amp;quot;, &amp;quot;GITHUB&amp;quot;, &amp;quot;BITBUCKET_SERVER&amp;quot;]
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "RepoType is required")]
    public required TerraformValue<string> RepoType
    {
        get => GetRequiredArgument<TerraformValue<string>>("repo_type");
        set => SetArgument("repo_type", value);
    }

    /// <summary>
    /// The fully qualified resource name of the Repo API repository. The fully qualified resource name of the Repo API repository.
    /// If unspecified, the repo from which the trigger invocation originated is assumed to be the repo from which to read the specified path.
    /// </summary>
    public TerraformValue<string>? Repository
    {
        get => GetArgument<TerraformValue<string>>("repository");
        set => SetArgument("repository", value);
    }

    /// <summary>
    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when resolving the
    /// filename (optional). This field respects the same syntax/resolution as described here: https://git-scm.com/docs/gitrevisions
    /// If unspecified, the revision from which the trigger invocation originated is assumed to be the revision from which to read the specified path.
    /// </summary>
    public TerraformValue<string>? Revision
    {
        get => GetArgument<TerraformValue<string>>("revision");
        set => SetArgument("revision", value);
    }

    /// <summary>
    /// The URI of the repo (optional). If unspecified, the repo from which the trigger
    /// invocation originated is assumed to be the repo from which to read the specified path.
    /// </summary>
    public TerraformValue<string>? Uri
    {
        get => GetArgument<TerraformValue<string>>("uri");
        set => SetArgument("uri", value);
    }

}


/// <summary>
/// Block type for github in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerGithubBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "github";

    /// <summary>
    /// The resource name of the github enterprise config that should be applied to this installation.
    /// For example: &amp;quot;projects/{$projectId}/locations/{$locationId}/githubEnterpriseConfigs/{$configId}&amp;quot;
    /// </summary>
    public TerraformValue<string>? EnterpriseConfigResourceName
    {
        get => GetArgument<TerraformValue<string>>("enterprise_config_resource_name");
        set => SetArgument("enterprise_config_resource_name", value);
    }

    /// <summary>
    /// Name of the repository. For example: The name for
    /// https://github.com/googlecloudplatform/cloud-builders is &amp;quot;cloud-builders&amp;quot;.
    /// </summary>
    public TerraformValue<string>? Name
    {
        get => GetArgument<TerraformValue<string>>("name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// Owner of the repository. For example: The owner for
    /// https://github.com/googlecloudplatform/cloud-builders is &amp;quot;googlecloudplatform&amp;quot;.
    /// </summary>
    public TerraformValue<string>? Owner
    {
        get => GetArgument<TerraformValue<string>>("owner");
        set => SetArgument("owner", value);
    }

    /// <summary>
    /// PullRequest block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 PullRequest block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerGithubBlockPullRequestBlock>? PullRequest
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerGithubBlockPullRequestBlock>>("pull_request");
        set => SetArgument("pull_request", value);
    }

    /// <summary>
    /// Push block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Push block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerGithubBlockPushBlock>? Push
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerGithubBlockPushBlock>>("push");
        set => SetArgument("push", value);
    }

}

/// <summary>
/// Block type for pull_request in GoogleCloudbuildTriggerGithubBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerGithubBlockPullRequestBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "pull_request";

    /// <summary>
    /// Regex of branches to match.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Branch is required")]
    public required TerraformValue<string> Branch
    {
        get => GetRequiredArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// Whether to block builds on a &amp;quot;/gcbrun&amp;quot; comment from a repository owner or collaborator. Possible values: [&amp;quot;COMMENTS_DISABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY&amp;quot;]
    /// </summary>
    public TerraformValue<string>? CommentControl
    {
        get => GetArgument<TerraformValue<string>>("comment_control");
        set => SetArgument("comment_control", value);
    }

    /// <summary>
    /// If true, branches that do NOT match the git_ref will trigger a build.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

}

/// <summary>
/// Block type for push in GoogleCloudbuildTriggerGithubBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerGithubBlockPushBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "push";

    /// <summary>
    /// Regex of branches to match.  Specify only one of branch or tag.
    /// </summary>
    public TerraformValue<string>? Branch
    {
        get => GetArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// When true, only trigger a build if the revision regex does NOT match the git_ref regex.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

    /// <summary>
    /// Regex of tags to match.  Specify only one of branch or tag.
    /// </summary>
    public TerraformValue<string>? Tag
    {
        get => GetArgument<TerraformValue<string>>("tag");
        set => SetArgument("tag", value);
    }

}


/// <summary>
/// Block type for pubsub_config in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerPubsubConfigBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "pubsub_config";

    /// <summary>
    /// Service account that will make the push request.
    /// </summary>
    public TerraformValue<string>? ServiceAccountEmail
    {
        get => GetArgument<TerraformValue<string>>("service_account_email");
        set => SetArgument("service_account_email", value);
    }

    /// <summary>
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    /// </summary>
    public TerraformValue<string> State
        => CreateReference("state");

    /// <summary>
    /// Output only. Name of the subscription.
    /// </summary>
    public TerraformValue<string> Subscription
        => CreateReference("subscription");

    /// <summary>
    /// The name of the topic from which this subscription is receiving messages.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Topic is required")]
    public required TerraformValue<string> Topic
    {
        get => GetRequiredArgument<TerraformValue<string>>("topic");
        set => SetArgument("topic", value);
    }

}


/// <summary>
/// Block type for repository_event_config in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerRepositoryEventConfigBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "repository_event_config";

    /// <summary>
    /// The resource name of the Repo API resource.
    /// </summary>
    public TerraformValue<string>? Repository
    {
        get => GetArgument<TerraformValue<string>>("repository");
        set => SetArgument("repository", value);
    }

    /// <summary>
    /// PullRequest block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 PullRequest block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerRepositoryEventConfigBlockPullRequestBlock>? PullRequest
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerRepositoryEventConfigBlockPullRequestBlock>>("pull_request");
        set => SetArgument("pull_request", value);
    }

    /// <summary>
    /// Push block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Push block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerRepositoryEventConfigBlockPushBlock>? Push
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerRepositoryEventConfigBlockPushBlock>>("push");
        set => SetArgument("push", value);
    }

}

/// <summary>
/// Block type for pull_request in GoogleCloudbuildTriggerRepositoryEventConfigBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerRepositoryEventConfigBlockPullRequestBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "pull_request";

    /// <summary>
    /// Regex of branches to match.
    /// 
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    /// </summary>
    public TerraformValue<string>? Branch
    {
        get => GetArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// Configure builds to run whether a repository owner or collaborator need to comment &#39;/gcbrun&#39;. Possible values: [&amp;quot;COMMENTS_DISABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED&amp;quot;, &amp;quot;COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY&amp;quot;]
    /// </summary>
    public TerraformValue<string>? CommentControl
    {
        get => GetArgument<TerraformValue<string>>("comment_control");
        set => SetArgument("comment_control", value);
    }

    /// <summary>
    /// If true, branches that do NOT match the git_ref will trigger a build.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

}

/// <summary>
/// Block type for push in GoogleCloudbuildTriggerRepositoryEventConfigBlock.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerRepositoryEventConfigBlockPushBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "push";

    /// <summary>
    /// Regex of branches to match.
    /// 
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    /// </summary>
    public TerraformValue<string>? Branch
    {
        get => GetArgument<TerraformValue<string>>("branch");
        set => SetArgument("branch", value);
    }

    /// <summary>
    /// If true, only trigger a build if the revision regex does NOT match the git_ref regex.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

    /// <summary>
    /// Regex of tags to match.
    /// 
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    /// </summary>
    public TerraformValue<string>? Tag
    {
        get => GetArgument<TerraformValue<string>>("tag");
        set => SetArgument("tag", value);
    }

}


/// <summary>
/// Block type for source_to_build in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerSourceToBuildBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "source_to_build";

    /// <summary>
    /// The full resource name of the bitbucket server config.
    /// Format: projects/{project}/locations/{location}/bitbucketServerConfigs/{id}.
    /// </summary>
    public TerraformValue<string>? BitbucketServerConfig
    {
        get => GetArgument<TerraformValue<string>>("bitbucket_server_config");
        set => SetArgument("bitbucket_server_config", value);
    }

    /// <summary>
    /// The full resource name of the github enterprise config.
    /// Format: projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}. projects/{project}/githubEnterpriseConfigs/{id}.
    /// </summary>
    public TerraformValue<string>? GithubEnterpriseConfig
    {
        get => GetArgument<TerraformValue<string>>("github_enterprise_config");
        set => SetArgument("github_enterprise_config", value);
    }

    /// <summary>
    /// The branch or tag to use. Must start with &amp;quot;refs/&amp;quot; (required).
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "RefAttribute is required")]
    public required TerraformValue<string> RefAttribute
    {
        get => GetRequiredArgument<TerraformValue<string>>("ref");
        set => SetArgument("ref", value);
    }

    /// <summary>
    /// The type of the repo, since it may not be explicit from the repo field (e.g from a URL).
    /// Values can be UNKNOWN, CLOUD_SOURCE_REPOSITORIES, GITHUB, BITBUCKET_SERVER Possible values: [&amp;quot;UNKNOWN&amp;quot;, &amp;quot;CLOUD_SOURCE_REPOSITORIES&amp;quot;, &amp;quot;GITHUB&amp;quot;, &amp;quot;BITBUCKET_SERVER&amp;quot;]
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "RepoType is required")]
    public required TerraformValue<string> RepoType
    {
        get => GetRequiredArgument<TerraformValue<string>>("repo_type");
        set => SetArgument("repo_type", value);
    }

    /// <summary>
    /// The qualified resource name of the Repo API repository.
    /// Either uri or repository can be specified and is required.
    /// </summary>
    public TerraformValue<string>? Repository
    {
        get => GetArgument<TerraformValue<string>>("repository");
        set => SetArgument("repository", value);
    }

    /// <summary>
    /// The URI of the repo.
    /// </summary>
    public TerraformValue<string>? Uri
    {
        get => GetArgument<TerraformValue<string>>("uri");
        set => SetArgument("uri", value);
    }

}


/// <summary>
/// Block type for timeouts in GoogleCloudbuildTrigger.
/// Nesting mode: single
/// </summary>
public class GoogleCloudbuildTriggerTimeoutsBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "timeouts";

    /// <summary>
    /// The create attribute.
    /// </summary>
    public TerraformValue<string>? Create
    {
        get => GetArgument<TerraformValue<string>>("create");
        set => SetArgument("create", value);
    }

    /// <summary>
    /// The delete attribute.
    /// </summary>
    public TerraformValue<string>? Delete
    {
        get => GetArgument<TerraformValue<string>>("delete");
        set => SetArgument("delete", value);
    }

    /// <summary>
    /// The update attribute.
    /// </summary>
    public TerraformValue<string>? Update
    {
        get => GetArgument<TerraformValue<string>>("update");
        set => SetArgument("update", value);
    }

}


/// <summary>
/// Block type for trigger_template in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerTriggerTemplateBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "trigger_template";

    /// <summary>
    /// Name of the branch to build. Exactly one a of branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    /// </summary>
    public TerraformValue<string>? BranchName
    {
        get => GetArgument<TerraformValue<string>>("branch_name");
        set => SetArgument("branch_name", value);
    }

    /// <summary>
    /// Explicit commit SHA to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// </summary>
    public TerraformValue<string>? CommitSha
    {
        get => GetArgument<TerraformValue<string>>("commit_sha");
        set => SetArgument("commit_sha", value);
    }

    /// <summary>
    /// Directory, relative to the source root, in which to run the build.
    /// 
    /// This must be a relative path. If a step&#39;s dir is specified and
    /// is an absolute path, this value is ignored for that step&#39;s
    /// execution.
    /// </summary>
    public TerraformValue<string>? Dir
    {
        get => GetArgument<TerraformValue<string>>("dir");
        set => SetArgument("dir", value);
    }

    /// <summary>
    /// Only trigger a build if the revision regex does NOT match the revision regex.
    /// </summary>
    public TerraformValue<bool>? InvertRegex
    {
        get => GetArgument<TerraformValue<bool>>("invert_regex");
        set => SetArgument("invert_regex", value);
    }

    /// <summary>
    /// ID of the project that owns the Cloud Source Repository. If
    /// omitted, the project ID requesting the build is assumed.
    /// </summary>
    public TerraformValue<string> ProjectId
    {
        get => GetArgument<TerraformValue<string>>("project_id") ?? CreateReference("project_id");
        set => SetArgument("project_id", value);
    }

    /// <summary>
    /// Name of the Cloud Source Repository. If omitted, the name &amp;quot;default&amp;quot; is assumed.
    /// </summary>
    public TerraformValue<string>? RepoName
    {
        get => GetArgument<TerraformValue<string>>("repo_name");
        set => SetArgument("repo_name", value);
    }

    /// <summary>
    /// Name of the tag to build. Exactly one of a branch name, tag, or commit SHA must be provided.
    /// This field is a regular expression.
    /// </summary>
    public TerraformValue<string>? TagName
    {
        get => GetArgument<TerraformValue<string>>("tag_name");
        set => SetArgument("tag_name", value);
    }

}


/// <summary>
/// Block type for webhook_config in GoogleCloudbuildTrigger.
/// Nesting mode: list
/// </summary>
public class GoogleCloudbuildTriggerWebhookConfigBlock : TerraformBlock
{
    /// <summary>
    /// Gets the block type.
    /// </summary>
    public override string BlockType => "webhook_config";

    /// <summary>
    /// Resource name for the secret required as a URL parameter.
    /// </summary>
    [System.ComponentModel.DataAnnotations.Required(ErrorMessage = "Secret is required")]
    public required TerraformValue<string> Secret
    {
        get => GetRequiredArgument<TerraformValue<string>>("secret");
        set => SetArgument("secret", value);
    }

    /// <summary>
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    /// </summary>
    public TerraformValue<string> State
        => CreateReference("state");

}


/// <summary>
/// Represents a google_cloudbuild_trigger Terraform resource.
/// Manages a google_cloudbuild_trigger resource.
/// </summary>
public partial class GoogleCloudbuildTrigger(string name) : TerraformResource("google_cloudbuild_trigger", name)
{
    /// <summary>
    /// Human-readable description of the trigger.
    /// </summary>
    public TerraformValue<string>? Description
    {
        get => GetArgument<TerraformValue<string>>("description");
        set => SetArgument("description", value);
    }

    /// <summary>
    /// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
    /// </summary>
    public TerraformValue<bool>? Disabled
    {
        get => GetArgument<TerraformValue<bool>>("disabled");
        set => SetArgument("disabled", value);
    }

    /// <summary>
    /// Path, from the source root, to a file whose contents is used for the template.
    /// Either a filename or build template must be provided. Set this only when using trigger_template or github.
    /// When using Pub/Sub, Webhook or Manual set the file name using git_file_source instead.
    /// </summary>
    public TerraformValue<string>? Filename
    {
        get => GetArgument<TerraformValue<string>>("filename");
        set => SetArgument("filename", value);
    }

    /// <summary>
    /// A Common Expression Language string. Used only with Pub/Sub and Webhook.
    /// </summary>
    public TerraformValue<string>? Filter
    {
        get => GetArgument<TerraformValue<string>>("filter");
        set => SetArgument("filter", value);
    }

    /// <summary>
    /// The id attribute.
    /// </summary>
    public TerraformValue<string> Id
    {
        get => GetArgument<TerraformValue<string>>("id") ?? CreateReference("id");
        set => SetArgument("id", value);
    }

    /// <summary>
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for &#39;**&#39;.
    /// 
    /// If ignoredFiles and changed files are both empty, then they are not
    /// used to determine whether or not to trigger a build.
    /// 
    /// If ignoredFiles is not empty, then we ignore any files that match any
    /// of the ignored_file globs. If the change has no files that are outside
    /// of the ignoredFiles globs, then we do not trigger a build.
    /// </summary>
    public TerraformList<string>? IgnoredFiles
    {
        get => GetArgument<TerraformList<string>>("ignored_files");
        set => SetArgument("ignored_files", value);
    }

    /// <summary>
    /// Build logs will be sent back to GitHub as part of the checkrun
    /// result.  Values can be INCLUDE_BUILD_LOGS_UNSPECIFIED or
    /// INCLUDE_BUILD_LOGS_WITH_STATUS Possible values: [&amp;quot;INCLUDE_BUILD_LOGS_UNSPECIFIED&amp;quot;, &amp;quot;INCLUDE_BUILD_LOGS_WITH_STATUS&amp;quot;]
    /// </summary>
    public TerraformValue<string>? IncludeBuildLogs
    {
        get => GetArgument<TerraformValue<string>>("include_build_logs");
        set => SetArgument("include_build_logs", value);
    }

    /// <summary>
    /// ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
    /// extended with support for &#39;**&#39;.
    /// 
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is empty, then as far as this filter is concerned, we
    /// should trigger the build.
    /// 
    /// If any of the files altered in the commit pass the ignoredFiles filter
    /// and includedFiles is not empty, then we make sure that at least one of
    /// those files matches a includedFiles glob. If not, then we do not trigger
    /// a build.
    /// </summary>
    public TerraformList<string>? IncludedFiles
    {
        get => GetArgument<TerraformList<string>>("included_files");
        set => SetArgument("included_files", value);
    }

    /// <summary>
    /// The [Cloud Build location](https://cloud.google.com/build/docs/locations) for the trigger.
    /// If not specified, &amp;quot;global&amp;quot; is used.
    /// </summary>
    public TerraformValue<string>? Location
    {
        get => GetArgument<TerraformValue<string>>("location");
        set => SetArgument("location", value);
    }

    /// <summary>
    /// Name of the trigger. Must be unique within the project.
    /// </summary>
    public TerraformValue<string> Name
    {
        get => GetArgument<TerraformValue<string>>("name") ?? CreateReference("name");
        set => SetArgument("name", value);
    }

    /// <summary>
    /// The project attribute.
    /// </summary>
    public TerraformValue<string> Project
    {
        get => GetArgument<TerraformValue<string>>("project") ?? CreateReference("project");
        set => SetArgument("project", value);
    }

    /// <summary>
    /// The service account used for all user-controlled operations including
    /// triggers.patch, triggers.run, builds.create, and builds.cancel.
    /// 
    /// If no service account is set, then the standard Cloud Build service account
    /// ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
    /// 
    /// Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
    /// </summary>
    public TerraformValue<string>? ServiceAccount
    {
        get => GetArgument<TerraformValue<string>>("service_account");
        set => SetArgument("service_account", value);
    }

    /// <summary>
    /// Substitutions data for Build resource.
    /// </summary>
    public TerraformMap<string>? Substitutions
    {
        get => GetArgument<TerraformMap<string>>("substitutions");
        set => SetArgument("substitutions", value);
    }

    /// <summary>
    /// Tags for annotation of a BuildTrigger
    /// </summary>
    public TerraformList<string>? Tags
    {
        get => GetArgument<TerraformList<string>>("tags");
        set => SetArgument("tags", value);
    }

    /// <summary>
    /// Time when the trigger was created.
    /// </summary>
    public TerraformValue<string> CreateTime
        => CreateReference("create_time");

    /// <summary>
    /// The unique identifier for the trigger.
    /// </summary>
    public TerraformValue<string> TriggerId
        => CreateReference("trigger_id");

    /// <summary>
    /// ApprovalConfig block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 ApprovalConfig block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerApprovalConfigBlock>? ApprovalConfig
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerApprovalConfigBlock>>("approval_config");
        set => SetArgument("approval_config", value);
    }

    /// <summary>
    /// BitbucketServerTriggerConfig block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 BitbucketServerTriggerConfig block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlock>? BitbucketServerTriggerConfig
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBitbucketServerTriggerConfigBlock>>("bitbucket_server_trigger_config");
        set => SetArgument("bitbucket_server_trigger_config", value);
    }

    /// <summary>
    /// Build block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Build block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerBuildBlock>? Build
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerBuildBlock>>("build");
        set => SetArgument("build", value);
    }

    /// <summary>
    /// DeveloperConnectEventConfig block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 DeveloperConnectEventConfig block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerDeveloperConnectEventConfigBlock>? DeveloperConnectEventConfig
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerDeveloperConnectEventConfigBlock>>("developer_connect_event_config");
        set => SetArgument("developer_connect_event_config", value);
    }

    /// <summary>
    /// GitFileSource block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 GitFileSource block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerGitFileSourceBlock>? GitFileSource
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerGitFileSourceBlock>>("git_file_source");
        set => SetArgument("git_file_source", value);
    }

    /// <summary>
    /// Github block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 Github block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerGithubBlock>? Github
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerGithubBlock>>("github");
        set => SetArgument("github", value);
    }

    /// <summary>
    /// PubsubConfig block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 PubsubConfig block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerPubsubConfigBlock>? PubsubConfig
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerPubsubConfigBlock>>("pubsub_config");
        set => SetArgument("pubsub_config", value);
    }

    /// <summary>
    /// RepositoryEventConfig block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 RepositoryEventConfig block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerRepositoryEventConfigBlock>? RepositoryEventConfig
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerRepositoryEventConfigBlock>>("repository_event_config");
        set => SetArgument("repository_event_config", value);
    }

    /// <summary>
    /// SourceToBuild block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 SourceToBuild block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerSourceToBuildBlock>? SourceToBuild
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerSourceToBuildBlock>>("source_to_build");
        set => SetArgument("source_to_build", value);
    }

    /// <summary>
    /// Timeouts block (nesting mode: single).
    /// </summary>
    public GoogleCloudbuildTriggerTimeoutsBlock? Timeouts
    {
        get => GetArgument<GoogleCloudbuildTriggerTimeoutsBlock>("timeouts");
        set => SetArgument("timeouts", value);
    }

    /// <summary>
    /// TriggerTemplate block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 TriggerTemplate block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerTriggerTemplateBlock>? TriggerTemplate
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerTriggerTemplateBlock>>("trigger_template");
        set => SetArgument("trigger_template", value);
    }

    /// <summary>
    /// WebhookConfig block (nesting mode: list).
    /// </summary>
    [System.ComponentModel.DataAnnotations.MaxLength(1, ErrorMessage = "Maximum 1 WebhookConfig block(s) allowed")]
    public TerraformList<GoogleCloudbuildTriggerWebhookConfigBlock>? WebhookConfig
    {
        get => GetArgument<TerraformList<GoogleCloudbuildTriggerWebhookConfigBlock>>("webhook_config");
        set => SetArgument("webhook_config", value);
    }

}
