using EmmittJ.Terraform.Sdk;

namespace EmmittJ.Terraform.Sdk.Providers.Google;

/// <summary>
/// Retrieves information about a google_cloud_run_service.
/// </summary>
public class GoogleCloudRunServiceDataSource : TerraformDataSource
{
    public GoogleCloudRunServiceDataSource(string name) : base("google_cloud_run_service", name)
    {
        InitializeOutputs();
    }

    private void InitializeOutputs()
    {
        this.DeclareOutput("autogenerate_revision_name");
        this.DeclareOutput("metadata");
        this.DeclareOutput("status");
        this.DeclareOutput("template");
        this.DeclareOutput("traffic");
    }

    /// <summary>
    /// The id attribute.
    /// </summary>
    public string? Id
    {
        get => GetProperty<TerraformLiteralProperty<string>>("id")?.Value;
        set => this.WithProperty("id", value == null ? null : new TerraformLiteralProperty<string>(value));
    }

    /// <summary>
    /// The location of the cloud run instance. eg us-central1
    /// </summary>
    public string? Location
    {
        get => GetProperty<TerraformLiteralProperty<string>>("location")?.Value;
        set => this.WithProperty("location", value == null ? null : new TerraformLiteralProperty<string>(value));
    }

    /// <summary>
    /// Name must be unique within a Google Cloud project and region.
    /// Is required when creating resources. Name is primarily intended
    /// for creation idempotence and configuration definition. Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// </summary>
    public string? Name
    {
        get => GetProperty<TerraformLiteralProperty<string>>("name")?.Value;
        set => this.WithProperty("name", value == null ? null : new TerraformLiteralProperty<string>(value));
    }

    /// <summary>
    /// The project attribute.
    /// </summary>
    public string? Project
    {
        get => GetProperty<TerraformLiteralProperty<string>>("project")?.Value;
        set => this.WithProperty("project", value == null ? null : new TerraformLiteralProperty<string>(value));
    }

    /// <summary>
    /// If set to &#39;true&#39;, the revision name (template.metadata.name) will be omitted and
    /// autogenerated by Cloud Run. This cannot be set to &#39;true&#39; while &#39;template.metadata.name&#39;
    /// is also set.
    /// (For legacy support, if &#39;template.metadata.name&#39; is unset in state while
    /// this field is set to false, the revision name will still autogenerate.)
    /// </summary>
    public TerraformExpression AutogenerateRevisionName => this["autogenerate_revision_name"];

    /// <summary>
    /// Metadata associated with this Service, including name, namespace, labels,
    /// and annotations.
    /// </summary>
    public TerraformExpression Metadata => this["metadata"];

    /// <summary>
    /// The current status of the Service.
    /// </summary>
    public TerraformExpression Status => this["status"];

    /// <summary>
    /// template holds the latest specification for the Revision to
    /// be stamped out. The template references the container image, and may also
    /// include labels and annotations that should be attached to the Revision.
    /// To correlate a Revision, and/or to force a Revision to be created when the
    /// spec doesn&#39;t otherwise change, a nonce label may be provided in the
    /// template metadata. For more details, see:
    /// https://github.com/knative/serving/blob/main/docs/client-conventions.md#associate-modifications-with-revisions
    /// 
    /// Cloud Run does not currently support referencing a build that is
    /// responsible for materializing the container image from source.
    /// </summary>
    public TerraformExpression Template => this["template"];

    /// <summary>
    /// Traffic specifies how to distribute traffic over a collection of Knative Revisions
    /// and Configurations
    /// </summary>
    public TerraformExpression Traffic => this["traffic"];

}
